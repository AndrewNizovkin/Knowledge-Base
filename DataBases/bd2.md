# SQL - создание объектов, изменение данных, логические операторы

## Числовые типы

**INT** — целочисленные значения от −2147483648 до 2147483647, 4 байта.

**DECIMAL** — хранит числа с заданной точностью. Использует два параметра — максимальное количество цифр всего числа (precision) и количество цифр дробной части (scale). Рекомендуемый тип данных для работы с валютами и координатами. Можно использовать синонимы NUMERIC, DEC, FIXED.

**TINYINT** — целые числа от −127 до 128, занимает 1 байт хранимой памяти.

**BOOL** — 0 или 1. Однозначный ответ на однозначный вопрос — false или true. Название столбцов типа boolean часто начинается с is, has, can, allow. По факту это даже не отдельный тип данных, а псевдоним для типа TINYINT (1). Тип настолько востребован на практике, что для него в MySQL создали встроенные константы FALSE (0) или TRUE (1). Можно использовать синоним BOOLEAN.

**FLOAT** — дробные числа с плавающей запятой (точкой).

**Символьные**

**VARCHAR(N)** — N определяет максимально возможную длину строки. Создан для хранения текстовых данных переменной длины, поэтому память хранения зависит от длины строки. Наиболее часто используемый тип строковых данных.

**TEXT** — подходит для хранения большого объема текста до 65 KB, например, целой статьи.

**CHAR -** строка фиксированной длины. Длина хранимой строки указывается в скобках, например, CHAR(10) - строка из десяти символов. И если в таблицу в данный столбец сохраняется строка из 6 символов (то есть меньше установленной длины в 10 символов), то строка дополняется 4 пробелами и в итоге все равно будет занимать 10 символов

**Дата и время**

**DATE** — только дата. Диапазон от 1000-01-01 по 9999-12-31. Подходит для хранения дат рождения, исторических дат, начиная с 11 века. Память хранения — 3 байта.

**TIME** — только время — часы, минуты, секунды — «hh:mm:ss». Память хранения — 3 байта.

**DATETIME** — соединяет оба предыдущих типа — дату и время. Использует 8 байтов памяти.

**TIMESTAMP** — хранит дату и время начиная с 1970 года. Подходит для большинства бизнес-задач. Потребляет 4 байта памяти, что в два раза меньше, чем DATETIME, поскольку использует более скромный диапазон дат.

## **Внешние ключи FOREIGN KEY**

Внешние ключи позволяют установить связи между таблицами. Внешний ключ устанавливается для столбцов из зависимой, подчиненной таблицы, и указывает на один из столбцов из главной таблицы. Как правило, внешний ключ указывает на первичный ключ из связанной главной таблицы. 

Общий синтаксис установки внешнего ключа на уровне таблицы:

```sql
FOREIGN KEY (столбец)
REFERENCES главная_таблица (столбец_главной_таблицы)
```

Для создания ограничения внешнего ключа после FOREIGN KEY указывается столбец таблицы, который будет представляет внешний ключ. А после ключевого слова REFERENCES указывается имя связанной таблицы, а затем в скобках имя связанного столбца, на который будет указывать внешний ключ. 

**Пример схемы базы данных (DDL):**

---

```sql
DROP OBJECT name_object  # удаляет объект(таблица, база данных,..)

DROP DATABASE test;

DROP TABLE table;

RENAME TABLE old_name TO new_name # переименовать таблицу
```

# DML (insert, update, delete, select)

Первая команда, которую мы изучим - заполнение таблицы данными.

- **INSERT – вставка новых данных**

Пусть имеются 2 столбца в таблицe Table: сolumn1, сolumn2

1. Заполняeтся только 1 столбец в таблицe Table
```sql
INSERT [INTO] Table (сolumn1)
VALUES (value1);
```
2. Заполняются все столбцы в таблицe Table.

```sql
INSERT Table
VALUES (value1, value2);
```
---

Псевдонимы - временное имя.

Псевдонимы делает имена столбцов более удобочитаемыми.

Псевдоним существует только на время выполнения запроса.

Посчитаем чек по заказу. Для этого умножаю количество на цену:

```sql
SELECT amount * count_order AS result # Псевдоним - result(будет заголовком)
FROM orders;
```

или задаётся с помощью пробела после имени столбца:

```sql
SELECT amaunt * count_order result — Псевдоним
FROM orders;
```

**2. Псевдоним таблицы - задается аналогично: с помощью пробела и слова AS:**

```sql
SELECT B.first_name, [B.id](http://b.id/), O.buyer_id, O.amount
FROM Orders O, Buyer B
WHERE O.buyer_id = [B.id](http://b.id/);
```

```sql
SELECT B.first_name, [B.id](http://b.id/), O.buyer_id, O.amount
FROM Orders AS O, Buyer AS B
WHERE O.buyer_id = [B.id](http://b.id/);
```

---

- **UPDATE  - обновление данных**

Команда применяется для обновления уже имеющихся строк

```sql
UPDATE имя_таблицы
SET столбец1 = значение1, столбец2 = значение2
[WHERE условие_обновления];
```

Пример:

```sql
UPDATE Orders
SET amount = amount * 0.75;
-- 100% цены = 1, 25% скидка = 0.25
-- Товар после уценки: 1.00 - 0.25 = 0.75
SELECT amount new_amount
FROM Orders;
```

TRUNCATE Orders; -- Удаляет все записи из таблицы Orders

---

- **DELETE - удаление данных**

```sql
DELETE FROM имя_таблицы
[WHERE условие_удаления];
```

Удаляет записи, соответствующие условию

---

# Операторы CASE, IF

```sql
CASE
  WHEN condition1 THEN result1
  WHEN condition2 THEN result2
  WHEN conditionN THEN resultN
  ELSE result
END;
```

Чтобы продемонстрировать пример на нашей таблице, немного обновим нашу таблицу. Для изменения таблицы используется оператор “ALTER TABLE

- - Добавить столбец "new_column" в таблицу "Table_name"

```sql
ALTER TABLE Table_name
ADD COLUMN new_column VARCHAR(50);
-- Удалить столбец "new_column" из таблицы "Table_name"
ALTER TABLE Table_name
DROP COLUMN new_column;
```

Давайте добавим в исходную таблицу столбец “статус”, в котором будет два значения: 

- 0 - заказ не оплачен
- 1 - заказ оплачен

Заполнение произведем с помощью функции для получения рандомного числа = **RAND().**

```sql
ALTER TABLE Orders
ADD COLUMN status INT AFTER count_order;
-- RAND(): https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_rand
-- Возращает числа от 0 до 1
UPDATE Orders
SET status = RAND();
```

---

**Задачка**: *в зависимости от значения поля “status” вывести сообщение о факте оплаты: “заказ оплачен”, “оплатите заказ”.*

```sql
SELECT *
FROM Orders;
SELECT status, -- Перед "CASE" ставится запятая, после перечисления столбцов
CASE 

  WHEN status IS TRUE THEN 'заказ оплачен'
  ELSE 'оплатите заказ'
END AS message
FROM Orders;
```

- - ИЛИ

```sql
SELECT status, -- Перед "CASE" ставится запятая, после перечисления столбцов
CASE WHEN status = 1 THEN 'заказ оплачен'
ELSE 'оплатите заказ'
END AS message
FROM Orders;
```

---

**Функция IF**

Функция IF в зависимости от результата условного выражения возвращает одно из двух значений. 

IF(условие, значение_для_истины, значение_для_лжи);

- - Представьте,что мы страхуем заказы со средним чеком от 3000 включительно.
-- Сообщим клиентам о наличии или отсутствии страховки
SELECT status, amount, count_order, manufacter,-- Перед "IF" тоже ставится запятая
IF(amount * count_order >= 3000, 'Cтраховка включена в стоимость', 'Страховка оплачивается отдельно') AS info_message
FROM Orders;

```sql
SELECT * FROM Prodacts
WHERE Manufacturer IN ("Apple", "Sumsung");
```

---

---

- [https://habr.com/ru/company/oleg-bunin/blog/348172/](https://habr.com/ru/post/255361/) - DDL, DCL на **MS SQL Server (1 часть).**
- https://habr.com/ru/post/255523/ - DDL, DCL на **MS SQL Server (2 часть).**