# ООП основные понятия и принципы

**Инкапсуляция** - свойство системы, позволяющее объединить данные и методы, работающие с ними в классе, скрыв детали реализации и защитив данные от пользователя этого класса.

**Наследование** - свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствованной функциональностью.

**Полиморфизм** - свойство системы использовать объекты с одинаковым интерфейсом без информации об их типе и внутренней структуре.

**Абстракция** - свойство системы, позволяющее описать общие характеристики для базового класса и для всех производных от него классов, а наполнение деталями предоставить каждому из них.

**ап кастинг** и **даун кастинг** - преобразование вверх и вниз

## Принципы SOLID

- **Srp - single responsibility principle** - принцип единственной ответственности. Обозначает, что каждый объект (метод, функция…) должен иметь одну ответственность и инкапсулировать в себе всё, что для этого необходимо. Благодаря этому ошибки, вызванные его модификациями не распространяются на другие, не связанные с ним объекты.

- **Ocp - open-closed principle** - принцип открытости/закрытости. Программные сущности (классы, модули, функции…) должны быть открыты для расширения, но закрыты для модификации. Это означает, что расширение(изменение) функционала сущности не должно затрагивать уже имеющийся функционал, что может негативно отразиться на работе связанного с этой сущностью кода. Идеально, чтобы класс выполнял больше операций, нужно добавить новый код, а не менять старый.

- **Lsp - Liskov substitution principle** - принцип подстановки Лисков(Барбары). Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом. Подкласс не должен требовать от вызывающего кода больше, чем базовый класс и не должен предоставлять вызывающему коду меньше, чем базовый класс. Родитель и потомок должны иметь возможность использоваться одинаковым образом без нарушения работы программы.

- **Isp - Interface segregation principle** - принцип разделения интерфейса. Много интерфейсов, специально предназначенных для клиентов лучше, чем один интерфейс общего назначения. Программные сущности не должны зависеть от методов, которые они не используют. Слишком “толстые” интерфейсы нужно разделять на более маленькие.

- **Dip - Dependency inversion principle** - принцип инверсии зависимостей. Зависимость на абстракциях. Нет зависимости на что-то конкретное. Модули(классы) верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций. Этот принцип служит для того, чтобы устранить зависимость классов верхнего уровня от классов нижнего уровня за счёт введения интерфейсов.

## Некоторые интерфейсы

Iterator<T> -  Реализация этого интерфейса в собственном типе позволяет присваивать экземпляр этого типа переменной типа Iterator<>

Iterable<component> - Реализация этого интерфейса в собственном типе позволяет перебирать компоненты component в цикле типа foreach

Comparator<T> - функциональный интерфейс. Его метод сравнивает два объекта <T> и возвращает отрицательный, положительный или нулевой int.

Comparable<> - налагает порядок на объекты класса, в котором реализуется и этот порядок называется естественным порядком класса, а метод `compareTo` его естественным методом сравнения. Рекомендуется согласовывать с `equals`. 

Cloneable, Serializable, Remote, EventListener…
```java
static {

инициализатор

}
// отрабатывает перед конструктором. Могут быть статическими и нестатическими.
```
Тернарные операторы могут быть вложенными

Double.compare(a1, a2) - для примитивных типов существуют фабричные методы compare. Для String существует метод compareTo() на уровне экземпляра. 

## Обобщения
Класс с обобщённым типом.

```java
class Stats<T>{

T value;

}
```

```java
static <T extends Comparable<T>, V extends<T>> boolean isIn(T x, V[] y) {} 
/// Параметр типа объявляется **до** типа, возвращаемого методом.
```
`<?>`- метасимвольный аргумент. Представляет неизвестный тип. 

`<? extends Number>` - ограничение в виде класса Number и всех его наследников.

`<T extends Number> Stats(T arg) {}` - конструктор с обобщённым аргументом.

`interface имя_интерфейса<список_параметров_типа> {}` - общая форма обобщённого интерфейса. 

`interface MinMax<T extends Comparable<T>> {}`

Класс, реализующий обобщённый интерфейс, также должен быть обобщённым.

`Class MyClass<T extends Comparable<T>> implements MinMax<T>`

Использование переменных базового типа допустимо (для совместимости со старым кодом), но не обеспечивает совместимость типов.

`<>` - выведение типов. Синтаксис, используемый при создании нового экземпляра (например).

Класс может реализовать обобщённый интерфейс. При этом либо быть обобщённым либо указать тип для интерфейса в объявлении класса.

В обобщённом методе `<>` стоит перед типом возвращаемого значения или void.

## НЕЛЬЗЯ:

- Создать экземпляр по параметру типа ~~ob = new T();~~

- использовать в статических членах параметр типа `static T ob; static T getOb() {}`

- создать массив объектов обобщённого типа `vals = T[10]` , но можно присвоить ссылку существующему массиву `T vals[] = nums`;

- Обобщённый класс не может расширять класс `Throwable`. Это означает, что создать обобщённый класс исключений нельзя.

## Архитектура приложения, паттерны проектирования.

MVP - model view presenter

MVC - model view controller

MVVM - model view view model

Классы, которые обрабатывают запросы называются контроллерами.

**Паттерны:**

- singleton - гарантируется только один объект. Экземпляр получается методом getInstance. Конструктор private

- builder - порождающий паттерн. Позволяет выполнять операции по цепочке.

- adapter - структурный паттерн. Наследует два интерфейса.
- observer - определяет зависимость объектов один ко многим.

