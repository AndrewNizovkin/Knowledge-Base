# SQL - выборка данных, сортировка, агрегатные функции.

# Терминология

**NULL** соответствует понятию «пустое поле»null, то есть «поле, не содержащее никакого значения».

**JOIN - о**ператор языка SQL, который является реализацией операции соединения реляционной алгебры.

**Группировка —** операция, которая создает из записей таблицы независимые группы записей, по которым проводится анализ.

**Агрегатные функции (агрегации) —** это функции, которые вычисляются от группы значений и объединяют их в одно результирующее.

- `SUM()` вычисляет сумму значений

- `MIN()` - минимальное значение

- `MAX()` - максимальное значение

- `AVG()` - среднее значение

- `COUNT()` - количество строк в столбце

---

```sql
-- IF EXISTS - проверка на наличие таблицы или любого другого объекта.
-- Таким образом можно запускать скрипт без ошибки о том, что объект уже создан.

-- IF NOT EXISTS - проверка на отсутсвие  объекта

CREATE TABLE  IF NOT EXISTS tbl (id INT(8)); 
-- Создадим таблицу, если ранее такой же не существовало

INSERT INTO tbl VALUES (5);
SELECT * FROM tbl;

DROP TABLE IF EXISTS tbl; -- Удалить таблицу tbl, если она существует 
CREATE TABLE tbl (id INT(8) ZEROFILL);

INSERT INTO tbl VALUES (5);
INSERT INTO tbl VALUES (500000000);
```

При объявлении целого типа в круглых скобках можно задать количество отводимых под число символов. Это **необязательное** указание количества выводимых символов используется для дополнения пробелами слева. Однако ограничений ни на диапазон величин, ни на количество разрядов не налагается. Если количества символов, необходимых для вывода числа, будет недостаточно, под столбец будет выделено больше символов. Если дополнительно указан необязательный атрибут `ZEROFILL`  , свободные позиции по умолчанию заполняются нулями слева.

---

# Календарные типы

MySQL поддерживает пять типов календарных типов:

-  `TIME`  предназначен для хранения времени в течение суток;

- `YEAR`  хранит год;

- `DATE`  хранит дату с точностью до дня;

- `DATETIME`  хранит дату и время;

- `TIMESTAMP`  также хранит дату и время, занимает в два раза меньше места, чем DATETIME, но может хранить только ограниченные даты — в интервале от 1970 года до 2038; Кроме того, первый TIMESTAMP-столбец в таблице обновляется автоматически при операциях создания и обновления. TIMESTAMP хранит дату в UTC-формате.

В таблице представлены календарные типы, именно в таких форматах MySQL возвращает
календарные значения.

**Тип**

`YEAR`  0000

`DATE`  '0000-00-00’

`TIME`  '00:00:00’

`DATETIME`  ‘0000-00-00 00:00:00’

`TIMESTAMP`  '0000-00-00 00:00:00’

---

С календарными типами можно проводить операции сложения и вычитания. Для этого используется специальная конструкция `INTERVAL` :

```sql
SELECT '2018-10-01 0:00:00' - INTERVAL 1 DAY;
SELECT '2018-10-01 0:00:00' + INTERVAL 1 WEEK;
SELECT '2018-10-01 0:00:00' + INTERVAL 1 YEAR;
SELECT '2018-10-01 0:00:00' + INTERVAL '1-1' YEAR_MONTH;
```

---

- - CURRENT_TIMESTAMP возвращает текущую дату и время
-- COMMENT - комментарий к объекту

---

```sql
DROP TABLE IF EXISTS products;

CREATE TABLE products (
id INT PRIMARY KEY AUTO_INCREMENT,
name VARCHAR(255) COMMENT 'Название',
description TEXT COMMENT 'Описание',
price DECIMAL (11,2) COMMENT 'Цена',
catalog_id INT UNSIGNED,
created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) COMMENT = 'Товарные позиции';

INSERT INTO products
(name, description, price, catalog_id)
VALUES
('Intel Core i3-8100', 'Процессор для настольных персональных компьютеров,
основанных на платформе Intel.', 7890.00, 1),
('Intel Core i5-7400', 'Процессор для настольных персональных компьютеров,
основанных на платформе Intel.', 12700.00, 1),
('AMD FX-8320E', 'Процессор для настольных персональных компьютеров,
основанных на платформе AMD.', 4780.00, 1),
('AMD FX-8320', 'Процессор для настольных персональных компьютеров, основанных
на платформе AMD.', 7120.00, 1),
('ASUS ROG MAXIMUS X HERO', 'Материнская плата ASUS ROG MAXIMUS X HERO, Z370,
Socket 1151-V2, DDR4, ATX', 19310.00, 2),
('Gigabyte H310M S2H', 'Материнская плата Gigabyte H310M S2H, H310, Socket
1151-V2, DDR4, mATX', 4790.00, 2),
('MSI B250M GAMING PRO', 'Материнская плата MSI B250M GAMING PRO, B250, Socket
1151, DDR4, mATX', 5060.00, 2);
CREATE TABLE users (
id INT PRIMARY KEY AUTO_INCREMENT,
name VARCHAR(255) COMMENT 'Имя покупателя',
birthday_at DATE COMMENT 'Дата рождения',
created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) COMMENT = 'Покупатели';
INSERT INTO users (name, birthday_at)
VALUES
('Геннадий', '1990-10-05'),
('Наталья', '1984-11-12'),
('Александр', '1985-05-20'),
('Сергей', '1988-02-14'),
('Иван', '2001-01-12'),
('Мария', '2002-08-29');
```

# Коллекционные типы

При объявлении списка допустимых значений `ENUM` и `SET` задаются списком строк, но во внутреннем представлении базы данных элементы множеств сохраняются в виде чисел. В случае `ENUM` поле может принимать лишь одно значение из списка. В случае `SET` — комбинацию заданных значений.

---

В последнее время большую популярность приобрел формат `JSON` , готовый объект языка JavaScript. Этот формат интенсивно используется для хранения и передачи коллекций. В `MySQL` предусмотрен столбец `JSON` -формата. Давайте добавим в таблицу **tbl** еще один столбец `JSON` -типа:

```sql
ALTER TABLE tbl ADD collect JSON; -- Добавили столбец "collect" с типом JSON

INSERT INTO tbl VALUES(1, '{"first": "Hello", "second": "World"}');
-- Пара ключ ключ:значение
SELECT * FROM tbl;
SELECT collect->>"$.first" FROM tbl;  -- Получить значение по ключу "first" - "Hello"

-- или

SELECT collect->>"$.first" AS first FROM tbl;  -- Получить значение по ключу "first" - "Hello"

SELECT collect->>"$.second" FROM tbl;  -- Получить значение по ключу "second" - "World"

-- или

SELECT collect->>"$.second" AS second FROM tbl;  -- Получить значение по ключу "second" - "World"
```
---

Пример:

Для начала, создадим новую таблицу:

```sql
CREATETABLE `products` (
`id` int(11) unsignedNOTNULL AUTO_INCREMENT,
`name` JSON,
`specs` JSON,
PRIMARY KEY (`id`)
) ENGINE=InnoDBDEFAULT CHARSET=latin1;

```

И добавим несколько значений:

```sql
INSERTINTO products VALUES (
null,
    '{"en": "phone", "it": "telefono"}',
    '{"colors": ["black", "white", "gold"], "size": {"weight": 1, "height": 1}}'
);

INSERTINTO productsVALUES(
null,
    '{"en": "screen", "it": "schermo"}',
    '{"colors": ["black", "silver"], "size": {"weight": 2, "height": 3}}'
);

INSERTINTO productsVALUES(
null,
    '{"en": "car", "it": "auto"}',
    '{"colors": ["red", "blue"], "size": {"weight": 40, "height": 34}}'
);
```

## **Считывание значений JSON**

Мы можем прочесть значения JSON-колонки используя простой синтаксис:

```sql
select
name->"$.en"as name,
specs->"$.size.weight"as weight,
specs->"$.colors"as colors
from products
```

---

# Сортировка.

Запрос выдает результаты в том порядке, в котором они хранятся в базе данных. Однако часто требуется отсортировать значения по одному из столбцов. Это делается при помощи конструкции `ORDER BY` . После конструкции`ORDER BY` указывается столбец (или столбцы), по которому следует cортировать данные.  По умолчанию сортировка производится в прямом порядке `ASC`, однако, добавив после имени столбца ключевое слово `DESC`, можно добиться сортировки в обратном порядке. 
Синтаксис:

```sql
SELECT expressions

  FROM tables

[WHERE conditions] 

 ORDER BY expression [ ASC | DESC ];
```

Пример:

```sql
SELECT * FROM products ORDER BY id; -- Запрос сортирует результат выборки по полю id

-- Чтобы отсортировать таблицу по каталогам, 
-- в рамках каждого каталога, по цене, мы можем указать
-- после ключевого слова ORDER BY сначала поле catalog_id, а затем поле price:

SELECT id, catalog_id, price, name FROM products ORDER BY catalog_id, price;
```

Если в `ORDER BY` указаны 2 столбца, то сначала сортировка производится по первому столбцу, затем - по второму.

### # Ограничение выборки в различных СУБД

---

```sql
TOP # SQL Server, MS Access

LIMIT # MySQL, PostgreSQL, SQLite

FETCH FIRST # Oracle
```

# Ограничения выборки. Оператор LIMIT

Результат выборки может содержать сотни и тысячи записей, их вывод и обработка занимают
значительное время и серьезно нагружают сервер базы данных. Поэтому информацию часто
разбивают на страницы и предоставляют ее пользователю порциями. Извлечение только части запроса требует меньше времени и вычислений, кроме того, пользователю часто бывает достаточно посмотреть первые несколько записей. Постраничная навигация используется при помощи ключевого слова `LIMIT`, за которым следует число выводимых записей.

```sql
SELECT * FROM products
ORDER BY name
LIMIT 2;
```

Здесь извлекаются первые две записи таблицы products, при этом записи сортируются по полю name. Чтобы извлечь следующие две записи, используется ключевое слово `LIMIT`с двумя числами. Первое указывает позицию, начиная с которой необходимо вернуть результат, а второе — количество извлекаемых записей.

```sql
SELECT * FROM products
ORDER BY name
LIMIT 2, 2;
```

Существует и альтернативная форма записи такого оператора, с использованием ключевого слова `OFFSET`:

```sql
SELECT * FROM products
ORDER BY name
LIMIT 2 OFFSET 2;

```

---

# Группировка данных. GROUP BY

Мы уже знаем механизм получения уникальных значений. В языке SQL для работы с такими группами предназначено специальное ключевое слово `GROUP BY.`

Синтаксис: (в “[]” указаны необязательные части)

```sql
SELECT столбцы
FROM таблица
[WHERE условие_фильтрации_строк]
[GROUP BY столбцы_для_группировки]
[HAVING условие_фильтрации_групп]
[ORDER BY столбцы_для_сортировки]
```

Пример:

```sql
-- Уникальные значения
SELECT DISTINCT catalog_id FROM products ORDER BY catalog_id; 
-- Группировка данных через GROUP BY
SELECT catalog_id FROM products GROUP BY catalog_id;
```

Оператор GROUP BY определяет, как строки будут группироваться.

В качестве значений для создания групп могут выступать не только столбцы таблицы, но и
вычисляемые значения. Например, давайте разделим пользователей в таблице на три группы:
родившихся в 80-х, 90-х и 2000-х годах. Для этого из даты рождения можно получить только первые 3 цифры. К примеру:

- 2001 год - первые 3 цифры - это “200” - обозначает, что человек родился в 2000 годах
- 1991 год - первые 3 цифры - это “199” - обозначает, что человек родился в 90 - х  годах

```sql
SELECT id, name, SUBSTRING(birthday_at, 1, 3) FROM users;
```

Здесь мы преобразуем календарный тип `DATETIME`  поля birthday_at к строковому значению и при помощи функции`SUBSTRING`   SUBSTRING извлекаем первые три цифры года рождения. Давайте назначим вычисляемому значению псевдоним при помощи ключевого слова `AS` и отсортируем значения при помощи `ORDER BY`

```sql
SELECT 
	id, name, 
	SUBSTRING(birthday_at, 1, 3) AS decade 
FROM users
ORDER BY decade;
```

Обратите внимание, что мы можем использовать псевдоним decade в конструкции `ORDER BY`.
При помощи конструкции GROUP BY мы можем сгруппировать поля по декадам.

Каждая из групп содержит в себе несколько пользователей и непонятно, какого из них следует выводить. Ранее MySQL выводила случайного пользователя, однако сейчас такое поведение отменено. Такой режим по-прежнему можно включить, СУБД даже подсказывает в сообщении об ошибке, как это можно сделать. Однако лучше этого не делать, чтобы ваш SQL-код оставался совместимым с другими СУБД. Какую пользу можно извлечь из сгруппированных значений? MySQL предоставляет несколько функций, которые называются агрегатными. Они позволяют работать с содержимым групп, полученных `GROUP BY`. Например, мы можем подсчитать количество записей внутри каждой из
групп:

```sql
SELECT COUNT(*), 
	SUBSTRING(birthday_at, 1, 3) AS decade
FROM users
GROUP BY decade;
```

значения мы по-прежнему можем сортировать при помощи конструкции `ORDER BY`.

```sql
SELECT
	COUNT(*),
	SUBSTRING(birthday_at, 1, 3) AS decade
FROM users
GROUP BY decade
ORDER BY decade DESC;
```

Причем сортировать можно не группируемому значению, но и по любому другому полю. Например, давайте назначим функции COUNT() псевдоним total и отсортируем результаты по этому значению:

```sql
SELECT
	COUNT(*) AS total,
	SUBSTRING(birthday_at, 1, 3) AS decade
FROM users
GROUP BY decade
ORDER BY total DESC;

```

Посмотреть содержимое группы мы можем при помощи специальной функции `GROUP_CONCAT`:

```sql
SELECT
	GROUP_CONCAT(name),
	SUBSTRING(birthday_at, 1, 3) AS decade
FROM users
GROUP BY decade;
```

Функция `GROUP_CONCAT`допускает задание разделителя, для этого внутри функции используется
ключевое слово `SEPARATOR`. Давайте зададим в качестве разделителя пробел:

```sql
SELECT
	GROUP_CONCAT(name SEPARATOR ' '),
	SUBSTRING(birthday_at, 1, 3) AS decade
FROM users
GROUP BY decade;
```

Ключевое слово `ORDER BY` позволяет отсортировать значения в рамках возвращаемой строки. Давайте отсортируем имена пользователей в обратном порядке:

```sql
SELECT
	GROUP_CONCAT(name ORDER BY name DESC SEPARATOR ' '),
	SUBSTRING(birthday_at, 1, 3) AS decade
FROM users
GROUP BY decade;
```

Агрегатные функции позволяют получать результаты для каждой из групп в отдельности. Чаще при составлении условий требуется ограничить выборку по результату функции, например выбрать группы, где количество записей больше или равно двум.
Использование для этих целей конструкции `WHERE` приводит к ошибке. Для решения этой проблемы вместо ключевого слова `WHERE` используется ключевое слово `HAVING` , которое располагается вслед за конструкцией `GROUP BY`. Выберем группы людей (рожденных в 80, 90,2000х),где количество людей больше, чем 2 человека:

- **WHERE фильтрует строки, а HAVING фильтрует группы.**
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fb5cc96f-d529-4d3d-8274-b8dfa1222384/Untitled.png)
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/91ac9fb4-dec5-4116-b52b-86b0312f2284/Untitled.png)
    

```sql
SELECT
	COUNT(*) AS total,
	SUBSTRING(birthday_at, 1, 3) AS decade
FROM users
GROUP BY decade
HAVING total >= 2;
```

# Агрегатные функции

**Агрегатные функции (агрегации)** — это функции, которые вычисляются от группы значений и объединяют их в одно результирующее**.**

Количество записей в таблице можно узнать при помощи функции `COUNT()`, которая принимает в качестве аргумента имя столбца. Функция возвращает число строк в таблице, значения столбца для которых отличны от **NULL.** 
В качестве параметра функции наряду с именами столбцов может выступать символ звездочки (*). При использовании символа * будет возвращено число строк таблицы независимо от того, принимают какие-то из них значение NULL или нет.

```sql
SELECT COUNT(*) FROM catalogs; -- Количество строк в таблице
SELECT COUNT(id) FROM catalogs; -- Количество id-шников в таблице
```

Конструкция GROUP BY разбивает таблицу на отдельные группы. Функция `COUNT()` возвращает результат для каждой из этих групп. 

```sql
SELECT 
	catalog_id, 
	COUNT(*) AS total 
FROM products 
GROUP BY catalog_id;
```

Функции `MIN()` и `MAX()` возвращают минимальное и максимальное значения столбца.

Получим максимальную и минимальную цену:

```sql
SELECT
	MIN(price) AS min,
	MAX(price) AS max
FROM products;
```

Функция `AVG()` возвращает среднее значение аргумента. Давайте подсчитаем среднюю цену товара в нашем магазине. Чтобы проверить поиск среднего значения, вспомним формулу: сумма всех значений / количество. Если решать задачку поиска среднего, то можно решить эту же задачку математически: `SUM(price)` / `COUNT(price)`

Для поиска суммы используем `SUM()` - поиск суммы внутри столбца.

```sql
SELECT 
	AVG(price) AS "Средняя цена через AVG",
  SUM(price) AS "Сумма товаров через SUM",
  COUNT(price) AS "Количество всех товаров через COUNT",
	SUM(price) / COUNT(price)  AS "Проверка ср. арифм"
FROM products;
```
### Вложенные запросы

Вложенные запросы позволяют нам получить или вычислить некоторое значение, а потом подставить в другой запрос.

Глубина вложенности не ограничена.