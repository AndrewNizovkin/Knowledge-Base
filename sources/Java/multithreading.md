# Урок 5. Многопоточность.

[Методичка](https://gbcdn.mrgcdn.ru/uploads/asset/5580418/attachment/5eec307a6443d172481c51cc9e567d8f.pdf)

---

### Введение

Давайте определим назначение процесса:

● Каждый процесс состоит из данных и кода, который их обрабатывает. Сам
процесс создается операционной системой при запуске приложения, что
является ресурсоёмкой задаче. Также процесс обладает собственным
виртуальным адресным пространством.

● Процессы работают независимо друг от друга, т.е. не имеют прямого доступа
к данным других процессов.

● Операционная система выделяет ресурсы (память, время выполнения) для
процесса.

● Если один из запущенных процессов заблокирован, то ни один другой
процесс не может выполняться, пока он не будет снята блокировка.

● Процесс может инициировать создание и контролировать дочерние
процессы, но он не может управлять процессами того же уровня.

Таким образом два приложения работающие под управлением одной операционной
системы — это два независимых процесса.

Любой процесс состоит из потоков. Потоки (также их можно назвать легковесными
процессами) выполняются параллельно друг с другом — они используют адресное
пространство процесса, которое делят между собой.

### Потоки исполнения

В самом общем смысле, чтобы запустить поток исполнения, нужно создать новый экземпляр класса Thread, передав ему параметром экземпляр класса, который реализует интерфейс Runnable, и выполнить метод `start()`.  Конструктор, который должен использоваться в данном случае:

```java
Thread(Runnable объект_потока, String имя_потока)
```

Второй способ состоит в создании класса, наследующего от Thread и выполнении `start()` для экземпляра этого класса.

Суть в том, что Thread реализует Runnable, в котором есть один лишь метод `run()`, который и определяет код потока.

```java
myThread = new Thread(Runnable runnable, String name);

myThread.isAlive() // True, если поток исполняется

myThread.join() // ожидает завершения потока, для которого вызывается

myThread.setPriority(int priority) // устанавливает приоритет

myThread.yield(); // уступает место другим потокам

```

Монитор - это понятие, используемое в качестве взаимоисключающей блокировки. Только один поток исполнения может в одно и то же время владеть монитором. Когда поток исполнения запрашивает блокировку, то говорят, что он *входит* в монитор. Все другие потоки, пытающиеся войти в заблокированный монитор, будут приостановлены до тех пор, пока первый поток не *выйдет* из монитора.

Состояние гонок - возникает, когда происходит одновременный вызов одного и того же метода для одного и того же объекта из нескольких разных потоков. Для избежания этого, достаточно предварить объявление метода ключевым словом `synchronized`

Если нужно синхронизировать доступ к объектам класса, не предназначенного для многопоточного доступа (в нём применяются несинхронизированные методы), то нужно заключить вызовы методов такого класса в блок оператора `synchronized`

```java
public void run() {
    synchronized(target) {
        target.call();
    }
}
```

### Взаимодействие потоков исполнения

Механизм взаимодействия потоков исполнения внедрён в Java с помощью методов `wait()`, `notify()` и `notifyAll()` , реализованные как конечные в классе Object, поэтому доступны во всех классах и могут быть вызваны **только из синхронизированного контекста.**

Правила применения этих методов состоят в следующем:

- `wait()` вынуждает вызывающий поток исполнения уступить монитор и перейти в состояние ожидания до тех пор, пока какой-нибудь другой поток не войдёт в тот же монитор и не вызовет метод `notify()` . **Oracle** рекомендует вызывать `wait()` в цикле, проверяющем условие, по которому поток ожидает возобновления, во избежание *ложной активации*.
- `notify()` возобновляет исполнение потока, из которого был вызван метод `wait()` для того же самого объекта.
- `notifyAll()` возобновляет исполнение всех потоков, из которых был вызван метод `wait()` для того же самого объекта. Одному из этих потоков предоставляется доступ.

Взаимная блокировка это ошибка, которую трудно отладить. В самом простом случае происходит в том случае, когда потоки исполнения имеют циклическую зависимость от пары синхронизированных объектов. 

Допустим, что один поток входит в монитор объекта X, а другой  - в монитор объекта Y. Если поток исполнения в объекте X попытается вызвать любой синхронизированный метод для объекта Y, он будет блокирован. Если поток в объекте Y, в свою очередь попытается вызвать любой синхронизированный метод для объекта X, то этот поток будет ожидать вечно

Для приостановки, возобновления и остановки потоков исполнения могут быть использованы методы `suspend()` , `resume()` и `stop()` , **не рекомендованные к употреблению**, по причине способности порождать серьёзные системные сбои.

Вместо этого код управления выполнением потока должен быть составлен таким образом, чтобы в методе `run()` периодически проверялось, должно ли исполнение потока быть приостановлено, возобновлено или прервано. Обычно для этой цели служит флаговая переменная, обозначающая состояние потока исполнения.

### Состояние потока исполнения

Чтобы получить текущее состояние потока исполнения, нужно вызвать метод `getState()` 

```java
Thread.State getState() // где Thread.State - это перечисление
```

Значения, возвращаемые `Thread.State` :

```java
BLOCKED // остановлен, ожидает получения блокировки
NEW // ещё не начал
RUNNABLE // выполняется или начнёт, когда получит доступ к ЦП
TERMINATED // завершил выполнение
TIMED_WAITING // приостановил выполнение на опр. промеж. вр. после методов
// sleep(), wait(), join()
WAITING // приостановил выполнение, ожидая действия после wait(), join() 
// без заданного времени ожидания
```

- Следует помнить:
    - создав слишком много потоков исполнения можно снизить производительность системы
    - переключение контекста с одного потока на другой требует издержек
    - в многоядерной системе, допускающей автоматическое масштабирование, рекомендуется пользоваться более продвинутыми технологиями, например Fork/Join Framework(@GerbertShildt-28)

## Пакеты параллельного прикладного интерфейса API

Средства параллелизма входят в состав пакетов `java.util.concurrent` и двух его подпакетов `java.util.concurrent.atomic` и `java.util.concurrent.locks`

В пакете `java.util.concurrent` определяются следующие основные средства параллелизма:

- Синхронизаторы
    
    1. Semaphore
    
    2. ContDownLatch
    
    3. CyclicBarrier
    
    4. Exchanger
    
    5. Phaser

- Исполнители

- Параллельные коллекции

- Каркас Fork/Join Framework

В пакете `java.util.concurrent.atomic` предоставляются средства, упрощающие применение переменных в параллельной среде. Для этой цели служат классы:

- AtomicInteger

- AtomicLong

А так же методы, которые действуют в режиме одной непрерывно выполняемой операции:

- compareAndSet()

- decrementAndGet()

- getAndSet()

В пакете `java.util.concurrent.locks` предоставляется альтернатива применению синхронизированных методов. В основу положен интерфейс `Lock` , определяющий механизм, применяемый для доступа к объекту и отказа в доступе. К основным методам из этого пакета относятся:

- lock()

- tryLock()

- unLolck()

# Применение объектов синхронизации

### Класс Semaphore

Семафор управляет доступом к общему ресурсу с помощью счётчика. Если счётчик больше нуля, доступ разрешён, а если он равен нулю, то в доступе будет отказано. Чтобы получить доступ к ресурсу, поток должен получит у семафора разрешение. Если в доступе отказано, поток будет заблокирован до тех пор, пока но не сумеет получить разрешение. После получения разрешения, значение счётчика семафора уменьшается на единицу. Если потоку исполнения доступ к общему ресурсу больше не нужен, он освобождает разрешение и счётчик семафора увеличивается на единицу.

```java
// число - исходное значение счётчика разрешений
// способ - по умолчанию(false) - доступ предоставляется произвольному потоку, 
// а если true, то в порядке обращения

Semaphore(int число)

Semaphore(int число, boolean способ)

// Методы:
// Получить разрешение
void acquire() throws InrerruptedException

// Освободить разрешение
void release()

```

### Класс CountDownLatch

Реализует самоблокировку с обратным отсчётом. Как только значение счётчика событий достигнет нуля, самоблокировка будет снята.

```java
// число - количество событий, которое должно произойти для сняния блокировки
CountDownLatch(int число)

// Методы:
// Известить о событии (уменьшает счётчик на 1)
void countDown()

// Ожидание по самоблокировке:
// до тех пор пока отсчёт не достигнет нуля:
void await() throws InterruptedException 

// Ожидание длится в течение ожидания в единицах_времени
// TimeUnit - перечисление

boolean await(long ожидание, TimeUnit единиица_времени) throws InterruptedException
```
Компоненты нового каркаса коллекций не являются потокобезопасными. Нужно воспользоваться алгоритмами из класса `Collections` типа `SinchronizedList`, чтобы получить их потокобезопасные версии.

В отличие от них, унаследованные классы `Stack`, `Properties`, `HashTable`, `Vector` являются потокобезопасными.


### Ключевое слово `volatile`

Если мы объявляем переменную с ключевым словом `volatile`, то это означает, что она будет атомарно читаться и записываться.

```java
public class Main {

   public volatile long x = 2222222222222222222L;

   public static void main(String[] args) {

   }
}
```



```java
CountDownLatch cd1 = new CountDownLatch(5);

```

### Класс CyclicBarrier

Определяет объект синхронизации, который приостанавливается до тех пор, пока определённое количество потоков не достигнет некоторой барьерной точки

```java
// здесь действие определяет поток, который будет исполняться по достижении барьера
CyclicBarrier(int количество_потоков)
CyclicBarrier(int количество_потоков, Runnable действие)

// Методы:
public int await()
          throws InterruptedException,
                 BrokenBarrierException
// Ожидает, пока все стороны не вызовут ожидание на этом барьере.
// Возвращает количество оставшихся

public int await(long timeout,
                 TimeUnit unit)
          throws InterruptedException,
                 BrokenBarrierException,
                 TimeoutException
                 
public boolean isBroken()
// апрашивает, находится ли этот барьер в сломанном состоянии.
```

### Класс Exchanger

Он ожидает до тех пор, пока два отдельных потока исполнения не вызовут его метод exchange(). Как только это произойдёт, он произведёт обмен данными, предоставляемыми обеими потоками. Класс является обобщённым:

```java
Exchanger<V>
```

В классе определяется единственный метод:

```java
V exchange(V буфер) throws InterruptedException

V exchange(V буфер, long ожидание, TimeUnit единица_времени) throws InterruptedException, TimeOutException
```

### Класс Phaser

Назначение - синхронизировать потоки исполнения, которые представляют одну или несколько стадий (или фаз) выполнения действий.

```java
Phaser phsr = new Phaser(1);

// Методы:

// Для регистрации стороны после создания объекта класса (в общем виде)
int n = phsr.register();
// возвращает номер регистрируемой фазы

// Чтобы сообщить о завершении фазы, сторона должна вызвать метод 
int n = phsr.arrive();
// возвращает текущий номер фазы или отрицательное число, если
// работа синхронизатора фаз завершена

// Если нужно указать завершение фазы и ожидать завершения этой фазы
// всеми остальными зарегистрированными сторонами:
int n = phsr.arriveAndAwaitAdvance();
// возвращает номер следующей фазы или отрицательное число

// Поток исполнения может достигнуть данной фазы и сняться с регистрации:
int n = phsr.arriveAndDeregister();
// возвращает номер следующей фазы или отрицательное число

int n = phsr.getPhase();
// возвращает текущий номер фазы

```

### Применение исполнителя

Это средство предназначено создания потоков исполнения и управления ими. Служит альтернативой управлению потоками исполнения средствами класса Thread

В основу исполнителя положен интерфейс Executor, в котором определяется метод:

```java
void execute(Runnable поток)
// в резултате исполняется указанный поток
```

Интерфейс ExecutorService расширяет Executor, дополняя его методами, помогающими управлять исполнением потоков и контролировать их, например:

```jsx
void shutdown() // останавливает все управляемые потоки
```

Интерфейс ScheduledExecutorService расширяет ExecutorService  для поддержки планирования потоков исполнения.

Кроме того имеются три предопределённых класса:

- ThreadPoolExecutor
- ScheduledThreadPoolExecutor
- ForkJoinPool реализует интерфейсы Executor и ExecutorService и применяется в каркасе Fork/Join Framework

Эти классы можно использовать напрямую, но можно получать исполнитель, вызывая один из статических фабричных методов, определённых во вспомогательном классе Executors:

```java
static ExecutorServece newCachedThreadPool()
// создаёт пул потоков исполнения, который вводит потоки по мере необходимости
// и позволяет повторно использовать их

static ExecutorServece newFixedThreadPool(int количество_потоков)
// создаёт пул из указанного количества_потоков

static ScheduledExecutorServece newScheduledThreadPool(int количество_потоков)
```

### Интерфейс Callable

Представляет поток исполнения, возвращающий значение. Является обобщённым:

```java
interface Callable<V>
// V - тип данных, возвращаемых потоком
```

В интерфейсе определяется единственный метод:

```java
V call() throws Exception
// в теле метода определяется задача. которую требуется выполнить
```

Для выполнения задачи типа Callable вызывается метод submit(), определённый в интерфейсе ExecutorService:

```java
<T> Future<T> submit(Callable<T> задача)
```

### Интерфейс Future

Представляет значение, возвращаемое объектом типа Callable и является обобщённым:

```java
interface Future<V>
```

Чтобы получить значение, следует вызвать метод get() из интерфейса Future:

```java
V get() throws InterruptedException, ExecutionException

V get(long ожидание, TimeUnit единица_времени) throws InterruptedException, 
ExecutionException, TimeoutException
```

### Перечисление TimeUnit

Служит для обозначения степени разрешения синхронизации:

- DAYS

- HOURS

- MINUTES

- SECONDS

- MICROSECONDS

- MILLISECONDS

- NANOSECONDS

### Параллельные коллекции

Ряд коллекций, предназначенных для выполнения параллельных операций:

- ArrayBlockingQueue

- ConcurrentHashMap

- ConcurrentLinkedDeque

- ConcurrentLinkedQueue

- ConcurrentSkipListMap

- ConcurrentSkipListSet

- CopyOnWriteArrayList

- CopyOnWriteArraySet

- DelayQueue

- LinkedBlockinDeque

- LinkedBlockinQueue

- PriorityBlockingQueue

- SynchronousQueue

Служат альернативой соответствующим классам коллекций из каркаса Collection Framework.

### Блокировки

Являются объектами и служат альтернативой блокам кода synchronized для управления доступом к общему ресурсу.

Блокировка определяется в интерфейсе Lock. Методы:

```java
// Для получения блокировки
void lock()
// ожидает, пока не будет получена вызываемая блокировка

// Чтобы снять блокировку
void unlock()

// Чтобы выяснить доступна ли блокировка, и, если да, получить её
boolean rtyLock()
// не входит в состояние ожидания

```

### Атомарные операции

Выполняются с помощью классов

- AtomicInteger

- AtomicLong

- AtomicBoolean

- AtomicReference

а также их методов

- get()

- set()

- compareAndSet()

- decrementAndSet()

- decrementAndGet()

- getAndSet()

В пакете java.util.concurrent.atomic, кроме того, предоставляются четыре класса, поддерживающие неблокируемые накопительные операции:

- DoubleAccumulator

- DoubleAdder

- LongAccumulator

- LongAdder

## Параллельное программирование средствами Fork/Join Framework

Упрощает создание и использование нескольких потоков исполнения и автоматизирует использование нескольких процессоров. Традиционная многопоточность с использованием Thread не совсем подходит для многоядерных компьютеров.

### Основные классы Fork/Join Framework

- ForkJoinTask<V> абстрактный класс, определяющий выполняемую задачу

- ForkJoinPool управляет выполнением задач типа ForkJoinTask

- RecursiveAction абстрактный класс является производным от класса ForkJoinTask<V> для выполнения задач, ***НЕ*** возвращающих значения

- RecursiveTask<V> абстрактный класс является производным от класса ForkJoinTask<V> для выполнения задач, возвращающих значения