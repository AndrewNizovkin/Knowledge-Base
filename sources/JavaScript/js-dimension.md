### Массивы


Два варианта создания массива:

```js
let arr = new Array();
let arr = [];
```

В JS массивы могут содержать элементы различных типов (не рекомендуется, вследствие падения эффективности);

```js
let arr = [ 'Яблоко', { name: 'Джон' }, true, function() { alert('привет'); } ];
```

Некоторые методы:

```js
array.at(-1); // предпоследний элемент

array.push(элемент); //добавляет элемент в конец массива

array.pop(); // удаляет (и возвращает) последний элемент

array.shift(); // удаляет (и возвращает) первый элемент

array.unshift(элемент); // добавляет элемент в начало массива

// Методы push/pop выполняются быстро, а методы shift/unshift – медленно.

arr.splice(start[, deleteCount, elem1, ..., elemN]);
//  изменяет arr начиная с индекса start: удаляет deleteCount элементов и затем вставляет elem1, ..., elemN на их место. Возвращает массив из удалённых элементов. start: можно отрицательный
// Пример удаление двух первых элементов:
let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];
let removed = arr.splice(0, 2);
alert( removed ); // "Я", "изучаю" <-- массив из удалённых элементов

// Метод splice также может вставлять элементы без удаления, для этого достаточно установить deleteCount в 0:
let arr = ["Я", "изучаю", "JavaScript"];
// с индекса 2
// удалить 0 элементов
// вставить "сложный", "язык"
arr.splice(2, 0, "сложный", "язык");

alert( arr ); // "Я", "изучаю", "сложный", "язык", "JavaScript"

arr.concat(arg1, arg2...)
// принимает любое количество аргументов, которые могут быть как массивами, так и простыми значениями.В результате – новый массив, включающий в себя элементы из arr, затем arg1, arg2 и так далее.

arr.forEach(function(item, index, array) {
  // ... делать что-то с item
});
// Пример:
["Бильбо", "Гэндальф", "Назгул"].forEach((item, index, array) => {
  alert(`У ${item} индекс ${index} в ${array}`);
});
// Пример:
["Бильбо", "Гэндальф", "Назгул"].forEach(alert);
// Результат функции (если она что-то возвращает) отбрасывается и игнорируется.

arr.indexOf(item, from); 
// ищет item начиная с индекса from и возвращает номер индекса, на котором был найден искомый элемент, в противном случае -1.

arr.includes(item, from);
// ищет item начиная с индекса from и возвращает true, если поиск успешен. from не обязателен

arr.find(function(item, index, array) {
 // если true - возвращается текущий элемент и перебор прерывается
 // если все итерации оказались ложными, возвращается undefined
 //Если функция возвращает true, поиск прерывается и возвращается item. Если ничего не найдено, возвращается undefined.
 // Пример:
let users = [
  {id: 1, name: "Вася"},
  {id: 2, name: "Петя"},
  {id: 3, name: "Маша"}
];
let user = users.find(item => item.id == 1);
});

arr.filter(function(item, index, array) {
  // если `true` -- элемент добавляется к results и перебор продолжается
  // возвращается пустой массив в случае, если ничего не найдено
});
// В отличии от find() возвращает массив из всех совпадений.


arr.map(function(item, index, array) {
  // возвращается новое значение вместо элемента
});
// вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции.

arr.sort();
// сортирует массив на месте, меняя в нём порядок элементов.
// По умолчанию элементы сортируются как строки!!!
// Чтобы использовать наш собственный порядок сортировки, нам нужно предоставить функцию в качестве аргумента arr.sort().
// Функция должна для пары значений возвращать, например:
function compare(a, b) {
  if (a > b) return 1; // если первое значение больше второго
  if (a == b) return 0; // если равны
  if (a < b) return -1; // если первое значение меньше второго
}
// Пример:
[1, -2, 15, 2, 0, 8].sort(function(a, b) {
  return a - b;
});
// На самом деле от функции сравнения требуется любое положительное число, чтобы сказать «больше», и отрицательное число, чтобы сказать «меньше».
arr.sort( (a, b) => a - b );
// Используйте localeCompare для строк
let countries = ['Österreich', 'Andorra', 'Vietnam'];
alert( countries.sort( (a, b) => a > b ? 1 : -1) ); // Andorra, Vietnam, Österreich (неправильно)
alert( countries.sort( (a, b) => a.localeCompare(b) ) ); // Andorra,Österreich,Vietnam (правильно!)

arr.reduce(function(accumulator, item, index, array) {
  // ...
}, [initial]);
// используются для вычисления единого значения на основе всего массива.
// accumulator – результат предыдущего вызова этой функции, равен initial при первом вызове (если передан initial),
// item – очередной элемент массива,
// index – его позиция,
// array – сам массив.
let arr = [1, 2, 3, 4, 5];
let result = arr.reduce((sum, current) => sum + current, 0);

// .......
```

Перебор массива:

```js
et arr = ["Яблоко", "Апельсин", "Груша"];

for (let i = 0; i < arr.length; i++) {
  alert( arr[i] );
}

for (let fruit of fruits) {
  alert( fruit );
}


for (let key in arr) {
  alert( arr[key] ); // Яблоко, Апельсин, Груша
}
// не лучший вариант, потому что перебирает все свойства объекта

// Пример с перебором свойств объекта:

let user = {
  name: "John",
  age: 30,
  isAdmin: true
};

for (let key in user) {
  // ключи
  alert( key );  // name, age, isAdmin
  // значения ключей
  alert( user[key] ); // John, 30, true
}
```

### Деструктурирующее присваивание

_Деструктурирующее присваивание_ – это специальный синтаксис, который позволяет нам «распаковать» массивы или объекты в несколько переменных, так как иногда они более удобны.

Деструктуризация массива:

```js
// у нас есть массив с именем и фамилией
let arr = ["Ilya", "Kantor"];

// деструктурирующее присваивание
// записывает firstName = arr[0]
// и surname = arr[1]
let [firstName, surname] = arr;

alert(firstName); // Ilya
alert(surname);  // Kantor
```

**Работает с любым перебираемым объектом с правой стороны**

### Деструктуризация объекта

```js
let {var1, var2} = {var1:…, var2:…}

// Пример:
let options = {
  title: "Menu",
  width: 100,
  height: 200
};
let {title, width, height} = options;
alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
```
