### Типы данных

В JavaScript есть 8 основных типов данных.

Семь из них называют «примитивными» типами данных:

- `number` для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном ±(2<sup>53</sup>).

- `bigint` для целых чисел произвольной длины.

- `string` для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.

- `boolean` для true/false.

- `null` для неизвестных значений – отдельный тип, имеющий одно значение null.

- `undefined` для неприсвоенных значений – отдельный тип, имеющий одно значение undefined.

- `symbol` для уникальных идентификаторов.

И один не является «примитивным» и стоит особняком:

- `object` для более сложных структур данных.

Оператор `typeof` позволяет нам увидеть, какой тип данных сохранён в переменной.

Имеет две формы: `typeof x`или `typeof(x)`.
Возвращает строку с именем типа. Например, "string".
Для `null` возвращается "object" – это ошибка в языке, на самом деле это не объект.

### Операторы сравнения

- `==` нестрогое сравнение ("10" == 10) true

- `===` строгое сравнение ("10" === 10) false

### Переменные 

Объявление переменных:

```js
let str = "stroka";

var str = 'stroka'; // Устаревшее
```

Использование ключевого слова `var` нежелательно. Переменная, объявленная таким образом видима вне блока {}. Кроме того, существует эффект "всплытия", когда объявление `var = ...` переменной фактически происходит в начале функции, вне зависимости от действительного её расположения в коде, а присвоение значения в момент обращения к ней.

### Вывод строк. Шаблонная строка.

В JS для вывода строк можно использовать символы `"`, `'` и `обратные  кавычки`. Последний вариант называется шаблонной строкой

```js
// Шаблонная строка
console.log(`Итог: ${a} + ${b} = {a + b}`)

// обратные кавычки ` позволяют разделять строку на части
let str = `
  Рабочая группа TC39 организации Ecma International -
  это группа JavaScript-разработчиков, теоретиков и авторов движков JavaScript,
  которые вместе с сообществом занимаются поддержкой и развитием языка JavaScript.
`;

```

Обратные кавычки позволяют разде

### Работа с примитивами

В JS можно обращаться к методам примитивов:

```js
alert((123.36).toFixed(1));
// метод toFixed округляет и возвращает строку

alert("12sdf4".length)
// length - не метод, а свойство, поэтому без()!

alert("12sdf4".[2])
alert("12sdf4".at(-2))
// получение символа из строки. В случае с 'at' возможна относительная адресация

alert( 'Interface'.toUpperCase() ); // INTERFACE

alert( 'Interface'.toLowerCase() ); // interface
```

Для округления чисел можно воспользоваться статическими методами класса `Math`:

```js
Math.flor();
// Округление в меньшую сторону 3.1->3 -1.1->-2

Math.ceil();
// Округление в большую сторону 3.1->4 -1.1->-1

Math.round();
// Округление до ближайшего целого 3.6->4 -1.1->-1

Math.trunc();
// Удаление дробной части 3.1->3 -1.1->-1
```

### Проверка: isFinite и isNaN

`Infinity` (и `-Infinity`) — особенное численное значение, которое ведёт себя в точности как математическая бесконечность ∞.

`NaN` представляет ошибку.


- `isNaN(value)` преобразует значение в число и проверяет является ли оно NaN:

```js
alert( isNaN(NaN) ); // true
alert( isNaN("str") ); // true
```

- `isFinite(value)` преобразует аргумент в число и возвращает true, если оно является обычным числом, т.е. не NaN/Infinity/-Infinity:

```js

isFinite("15"); // true
alert( isFinite("str") ); // false, потому что специальное значение: NaN

alert( isFinite(Infinity) ); // false, потому что специальное значение: Infinity
```

### parseInt и parseFloat

Они «читают» число из строки. Если в процессе чтения возникает ошибка, они возвращают полученное до ошибки число. Функция parseInt возвращает целое число, а parseFloat возвращает число с плавающей точкой:

```js
alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5

alert( parseInt('12.3') ); // 12, вернётся только целая часть
alert( parseFloat('12.3.4') ); // 12.3, произойдёт остановка чтения на второй точке
```

Функции parseInt/parseFloat вернут NaN, если не смогли прочитать ни одну цифру:

```js
alert( parseInt('a123') ); // NaN, на первом символе происходит остановка чтения
```

Функция parseInt() имеет необязательный второй параметр. Он определяет систему счисления, таким образом parseInt может также читать строки с шестнадцатеричными числами, двоичными числами и т.д.:

```js
alert( parseInt('0xff', 16) ); // 255
alert( parseInt('ff', 16) ); // 255, без 0x тоже работает

alert( parseInt('2n9c', 36) ); // 123456
```

### Symbol

Символ (symbol) – примитивный тип данных, использующийся для создания уникальных идентификаторов.

Символы создаются вызовом функции Symbol(), в которую можно передать описание (имя) символа.

Даже если символы имеют одно и то же имя, это – разные символы. Если мы хотим, чтобы одноимённые символы были равны, то следует использовать глобальный реестр: вызов Symbol.for(key) возвращает (или создаёт) глобальный символ с key в качестве имени. Многократные вызовы команды Symbol.for с одним и тем же аргументом возвращают один и тот же символ.

Символы имеют два основных варианта использования:

«Скрытые» свойства объектов.

Если мы хотим добавить свойство в объект, который «принадлежит» другому скрипту или библиотеке, мы можем создать символ и использовать его в качестве ключа. Символьное свойство не появится в for..in, так что оно не будет нечаянно обработано вместе с другими. Также оно не будет модифицировано прямым обращением, так как другой скрипт не знает о нашем символе. Таким образом, свойство будет защищено от случайной перезаписи или использования.

Так что, используя символьные свойства, мы можем спрятать что-то нужное нам, но что другие видеть не должны.

Существует множество системных символов, используемых внутри JavaScript, доступных как Symbol.*. Мы можем использовать их, чтобы изменять встроенное поведение ряда объектов. Например, в дальнейших главах мы будем использовать Symbol.iterator для итераторов, Symbol.toPrimitive для настройки преобразования объектов в примитивы и так далее.

Символы игнорируются циклом for…in

```js
let id = Symbol("id");

alert(id.toString()); // Symbol(id), теперь работает

ert(id.description); // id

// Создадим скрытое свойство

let user = {
  name: "Вася"
};

let id = Symbol("id");

user[id] = 1;

alert( user[id] ); // мы можем получить доступ к данным по ключу-символу
```