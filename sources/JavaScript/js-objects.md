# Объекты в JavaScript

### Опциональная цепочка

Опциональная цепочка `?`. останавливает вычисление и возвращает `undefined`, 
если значение перед `?`. равно `undefined` или `null`.

Это помогает избегать ошибок при обращении к несуществующему свойоству объекта.

Вот безопасный способ получить доступ к user.address.street, используя ?.:

```js
let user = {}; // пользователь без адреса

alert( user?.address?.street ); // undefined (без ошибки)
```

### Примеси

 _**примесь**_ – это класс, методы которого предназначены для использования в других классах, причём без наследования от примеси.

Простейший способ реализовать примесь в JavaScript – это создать объект с полезными методами, которые затем могут быть легко добавлены в прототип любого класса:

```js
// примесь
let sayHiMixin = {
  sayHi() {
    alert(`Привет, ${this.name}`);
  },
  sayBye() {
    alert(`Пока, ${this.name}`);
  }
};

// использование:
class User {
  constructor(name) {
    this.name = name;
  }
}

// копируем методы
Object.assign(User.prototype, sayHiMixin);

// теперь User может сказать Привет
new User("Вася").sayHi(); // Привет, Вася!

```

### Прототипное наследование

В JavaScript объекты имеют специальное скрытое свойство [[Prototype]] (так оно названо в спецификации), которое либо равно null, либо ссылается на другой объект. Этот объект называется «прототип».

Свойство [[Prototype]] является внутренним и скрытым, но есть много способов задать его.

Одним из них является использование __proto__, например так:


```js
let animal = {
  eats: true
};

let rabbit = {
  jumps: true
};

rabbit.__proto__ = animal; // (*)

// теперь мы можем найти оба свойства в rabbit:
alert( rabbit.eats ); // true (**)
alert( rabbit.jumps ); // true
```

Цепочка прототипов может быть длиннее:

```js
let animal = {
  eats: true,
  walk() {
    alert("Animal walk");
  }
};

let rabbit = {
  jumps: true,
  __proto__: animal
};

let longEar = {
  earLength: 10,
  __proto__: rabbit
};

// walk взят из цепочки прототипов
longEar.walk(); // Animal walk
alert(longEar.jumps); // true (из rabbit)

```

Свойство __proto__ немного устарело, оно существует по историческим причинам. Современный JavaScript предполагает, что мы должны использовать функции Object.getPrototypeOf/Object.setPrototypeOf вместо того, чтобы получать/устанавливать прототип.

### JSON

> JSON (JavaScript Object Notation) – это общий формат для представления значений и объектов.

JavaScript предоставляет методы:

- **`JSON.stringify`** для преобразования объектов (и примитивов) в JSON.

  ```js
  let json = JSON.stringify(value[, replacer, space])
  ```
  - `value` Значение для кодирования.

  - `replacer` Массив свойств для кодирования или функция соответствия `function(key, value)`.
  
  - `space` Дополнительное пространство (отступы), используемое для форматирования.

- **`JSON.parse`** для преобразования JSON обратно в объект.

  ```js
  let value = JSON.parse(str[, reviver]);
  ```

  - `str` JSON для преобразования в объект.

  - `reviver` Необязательная функция, которая будет вызываться для каждой пары (ключ, значение) и может преобразовывать значение.

```js
let student = {
  name: 'John',
  age: 30,
  isAdmin: false,
  courses: ['html', 'css', 'js'],
  wife: null
};

let json = JSON.stringify(student);

alert(typeof json); // мы получили строку!
// Полученная строка json называется JSON-форматированным или сериализованным объектом. 

alert(json);
```

Объект в формате JSON имеет несколько важных отличий от объектного литерала:

- Строки используют двойные кавычки. Никаких одинарных кавычек или обратных кавычек в JSON. Так 'John' становится "John".

- Имена свойств объекта также заключаются в двойные кавычки. Это обязательно. Так age:30 становится "age":30.

JSON является независимой от языка спецификацией для данных, поэтому JSON.stringify пропускает некоторые специфические свойства объектов JavaScript.

А именно:

- Свойства-функции (методы).

- Символьные ключи и значения.

- Свойства, содержащие `undefined`.