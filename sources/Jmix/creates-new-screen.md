# Создание экрана с "чистого листа".

Добавляем в проект `+` новый `View` тип `Blank view` и заполняем поля в мастере для названий дескриптора (разделитель "-") и контроллера(camel case).

Если экран не должен находиться в главном меню приложения, нужно удалить значение для `Parent menu item`.

Для заполнения аннотаций контроллера служат поля 

- `View id` идентификатор для этого экрана, например Task_.detail

- `View route` определяет часть URL, определяющей этот экран, например tasks/:id (Чтобы понять какую задачу нужно отобразить)

На следующем шаге заполняем заголовок.

## Descriptor

Добавляем контейнер данных. Для этого в палитре компонентов `Add Component` найдём и выберем компонент `Instance Container`. В появившемся диалоге выберем сущность, с которой работает данный контейнер (Task_).

Редактируем `Fetch Plan`, кликнув "карандашик" слева от блока `instance`. Например, включим `assignee` и `project`, включив  для обоих Fetch plan `_instance_name`.

Добавим через `Add Component` фасет `DataLoadCoordinator`. Это гарантирует, что данные будут загружаться автоматически.

Добавим несколько действий для экрана, выбрав `Add > Actions` из контекстного меню пункта `view` в панели иерархии, таких как `detail_close` и `detail_saveClose`. Эти действия закрывают окно.

Редактируем класс контроллера `TaskDetailView`. Делаем его наследником `StandardDetailView<Task>`.

Укажем контроллеру, какой контейнер использовать. Для этого добавим аннотацию `@EditedEntityContainer("taskDc")`

### Добавляем визуальные компоненты

В `Add Component` выберем `FormLayout`. Это адаптивный контейнер компонентов, который может размещать компоненты в один или несколько столбцов, в зависимости от ширины страницы. В открывшемся диалоге нужно выбрать нужный контейнер данных (taskDc) - поле`Data container`. Таким образом, в дескриптор будут вставлены компоненты для работы с каждым из атрибутов, имеющихся в контейнере даных.

На панели свойств (справа) можно изменять свойства или добавлять действия для компонентов, кликнув `+ Add` и выбрав `Actions > Action`.

Например, для компонентов `entityPicker` нужно добавить стандартные действия `entity_clear` и `entity_lookup` для очитски поля и вызова диалога о информации о сущности.

Установив курсор в нужном месте, например после всех компонентов, перед закрывающим тегом `</formLayout>`, вставим горизонтальный блок с двумя кнопками. Для этого выберем `Add Component` из контекстного меню пункта `layout` в панели иерархии и найдём `hbox`. 

Следуя вышеописанному алгоритму, добавим в него две кнопки `Button`. Этим кнопкам, через панель свойств, добавим действия `detailClose` и `detailSaveClose` и укажем `id`

Положение компонентов можно менять перетаскиванием их в дереве компонентов на панели справа.

### Режим диалогового окна

Чтобы задать экрану режим отображения в виде диалогового окна, нужно к контроллеру добавить аннотацию `@DialogMode(width="AUTO", height="AUTO")`

В дескрипторе `project-detail-view.xml` найдём определения для действий создания `create` и редактирования `edit`.
Используя панель свойств, установим `openMode` в `DIALOG`

## Controller. Обработка событий. 

### Установка значения по умолчанию при создании сущности

Открываем `TaskDetailView.java`  и кликаем в панели инструментов `Generate Handler`.

В открывшемся диалоге выбираем, например, `InitEntityEvent<Task>` это событие происходит, когда создаётся новый объект `Task`.

Для того, чтобы при создании нового объекта устанавливался приоритет `MEDIUM`, пишем код для созданного метода:

```java
event.getEntity().setPriority(TaskPriority.MEDIUM);
```

### Счётчик оставшихся символов для TextArea

В дескрипторе:

1. Установим значение свойства `maxLenth` в `500` для нужного компонента `textArea`. 

2. Установим значение свойства `valueChangeMode` в `EAGER`. Это позволит получать мгновенные обновления при каждом изменении текста.

3. На панели свойств переключаемся на вкладку `Handlers` и в предложенном списке выбираем событие `ComponentValueChangeEvent`. Добавляем описание. Получаем новый метод в контроллере. 

В контроллере:

```java
event.getSource().setHelperText(event.getValue().toString().length() + "/" + 500);
```

Теперь при заполнении поля `Description` внизу будет отображаться счётчик.

> Обратиться к компоненту из контроллера экрана можно по значению атрибута `id`.