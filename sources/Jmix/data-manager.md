# Работа с данными. Интерфейс DataManager.

Интерфейс `DataManager` предоставляет методы для CRUD операций с хранилищами данных. Позволяет создавать запросы на языке JPql.

`DataManager` инжектируется либо в файл контроллера, либо в Spring Bean, который содержит бизнес логику приложения и создается через меню `+`

Можно инжектировать через меню `Inject`

В этом бине создаются методы, в которых используется `dataManager` для загрузки сущностей.

```java
@Component
public class ProjectService {
    private final DataManager dataManager;

    public ProjectService(DataManager dataManager) {
        this.dataManager = dataManager;
    }

    public addProject() {
        dataManager.load(Project.class);
        // бизнес логика работы с данными репозитория
    }
}
```

`DataManager` позволяет загружать сущности по идентификатору, по условию, а также по JPQL запросу.

### Загрузка по идентификатору

```java
User loadById(UUID userId) {
    return dataManager.load(User.class)
        .id(userId)
        .one();
// Если сущности с указанным идентификатором не существует – будет выброшено исключение. Если такое недопустимо, то вместо one() можно использовать метод optional(
}
```
> Если сущности с указанным идентификатором не существует – будет выброшено исключение. Если такое недопустимо, то вместо `one()` можно использовать метод `optional()`

### Загрузка по условию

Загрузка сущности по условию подойдет для фильтрации и поиска экземпляров сущности. В данном примере используется метод `contains()` для адресов электронной почты

```java
List<User> loadByCondition() {
    return dataManager.load(User.class)
        .condition(PropertyCondition.contains("email", "@company.com"))
        .list();
}
```

Кроме `contains()` присутствует много других методов фильтрации: `endsWith()`,  `startsWith()`, методы сравнения по `less()`, `greater()`, `greaterOrEqual()`, проверка на принадлежность к списку `inList()`.

> 
Важно отметить, что если никакое значение не указано, то и условие применено не будет – в примере выше будут загружены все имеющиеся экземпляры сущности User. В то время как в пользовательском интерфейсе такое поведение необходимо, в бизнес-логике оно обычно нежелательно. Поэтому, если значение параметра может оказаться пустым, лучше использовать загрузку с помощью запросов.

### Загрузка по запросу JPQL

Пример выше можно переписать, используя запрос JPQL. Он может быть помещен внутри специального метода query().  Параметры передаются в запрос с помощью одноименного метода paramater().

```java
List<User> loadByQuery() {
    return dataManager.load(User.class)
            .query("select u from User u where u.email like :email")
            .parameter("email", "%@company.com")
            .list();
}
```

### JPQL

Java Persistance Quary Lanauage - язык запросов, который в отличии от SQL, на который очень похож, работает с объектами, атрибутами и отношениями, а не с таблицами и столбцами.

Интерфейс `DataManager` позволяет выполнять JPQL-запросы SELECT и создавать объекты, которые являются результатом запроса.

В Jmix-студии присутствует специальный редактор, получить доступ к которому можно через меню `Code Snippets > Data > Load list of entities by query`, например. И если такой сниппет подразумевает использование JPQL, то студия предложить заполнить запрос в редакторе. В результате будет сфоммирован запрос в коде.

При необходимости в редактор можно вернуться. Для этого нужно кликнуть иконку "карандаш" слева.

Примеры запросов:

```sql

select t.name from Task t where t.priority = :priority and t.assignee = :assignee

select sum(te.timeSpent) from TimeEntry te where te.task.project.name = "Marketing"
```


