# Подсистема безопасности.

> Основана на Spring Sequrity, что позволяет при необходимости интегрировать в программу доп. возможности или альтернативные решения.

Подсистема безопасности предоставляет легко настраиваемые механизмы для обеспечения безопасности как для аутентификации, так и для авторизации. Она обладает следующими возможностями:

- Интеграция с моделью данных, что позволяет создавать разрешения для вызова CRUD-операций над сущностями, а также на просмотр или изменение определённых атрибутов сущности. Существует возможность ограничить доступ к определённым экземплярам сущности.

- Интеграция с пользовательским интерфейсом, что позволяет создавать разрешение для открытия экранов и показа пунктов главного меню.

- Если пользователю запрещены CRUD-операции для сущности, то будут автоматически отключены соответствующие действия с таблицей, где представлена эта сущность. То-же справедливо для полей, привязанных к атрибутам, они могут быть "только для чтения" или скрытыми.

Определение ролей в коде происходит с помощью аннотированных интерфейсов. Студия предоставляет визуальный редактор и код может быть сгенерирован автоматически.

Созданные роли и их политики доступны для просмотра в программе на специальном экране, где администратор может назначать роли пользователям, экспортировать и импортировать роли.

Роли можно создавать не только во время разработки, но и во время выполнения программы.

Центральным элементом подсистемы является пользователь `User`.

### Встроенные пользователи

- **Admin** Содержится в новом проекте по умолчанию. Имеет роль полного доступа FullAccesRole и обладает всеми разрешениями. Хранится в базе данных.

- **Anonymous** Соответствует не прошедшим аутентификацию пользователям. Позволяет пользователю некоторые разрешения до того, как он войдёт в систему. По умолчанию не имеет никаких разрешений.

- **System** Требуется для механизма системной аутентификации, когда с приложением взаимодействует некоторый сервис.

### Получение и работа с текущим пользователем.

Для определения из кода программы, какой пользователь аутентифицирован, служат методы, определённые в интерфейсе `CurrentAuthentication`.

Например: добавим автозаполнение поля `User` при инициализации экрана `TimeEntryDetailView`.

Добавим в контроллер экрана код, определяющий текущего пользователя используя `Code Snippets` -> `Get current user`.

```java
public class TimeEntryDetailView extends StandardDetailView<TimeEntry> {

    @Autowired
    private CurrentAuthentication currentAuthentication;

    @Subscribe
    public void onInitEntity(final InitEntityEvent<TimeEntry> event) {

        // Подстановка текущей даты
        event.getEntity().setEntryDate(LocalDateTime.now());

        // Подстановка текущего пользователя
        final User user = (User) currentAuthentication.getUser();
        event.getEntity().setUser(user);
    }
}
```

### Роли и политики

Роли в Jmix — это наборы политик, которые предоставляют пользователям доступ к различным ресурсам в приложении Jmix. Они позволяют ограничить доступ пользователей к минимально необходимой части функциональности. Пользователь без ролей не имеет разрешений и не сможет получить доступ к системе.

В приложении Jmix пользователю может быть присвоено несколько ролей двух различных типов: `ресурсных ролей` и `ролей уровня строк`.

Ресурсные роли являются позитивными, разрешающими.

Роли уровня строк являются негативными, запрещающими.

Разрешения и ограничения разных политик складываются.

USER:

- Resource Role

        - Entity Policy

        - Entity Attribute Policy

        - Screen Policy

        - Menu Policy

        - Specific Policy

- Row-lever Role

        - JPQL Policy

        - Predicate Policy

### Встроенные роли. UI: minimal access

Jmix и его аддоны имеют свои встроенные роли. Одной из важнейших является минимальная роль пользовательского интерфейса `UI: minimal access`. Она содержит разрешения на основные ресурсы пользовательского интерфейса Jmix.

Эта роль должна быть назначена любому пользователю, которому требуется доступ к пользовательскому интерфейсу приложения. Существуют также ряд пользователей, которым такой доступ не требуется. Например, те, которые получают доступ к приложению через REST API или настраиваемые веб-сервисы.

Роли различают по уровню детальности:

- `Крупномасштабная` включают все типы привелегии, необходимые конкретному типу 

- `Детализированная` определяют одну функциональность

- `Комбинированная` включают несколько детализированных. Из них могут составлены более крупномасштабные роли.

> Рекомендуется создавать детализированные роли во время разработки и использовать UI приложения только для их объединения в различные крупномасштабные роли для простого назначения пользователям и для редких специальных изменений в модели безопасности.

### Создание ресурсной роли

`+` > `ResourceRole`

В результате будет создан и открыт в редакторе файл *.java

Внизу находится панель редактора ролей.

- Переходим на вкладку `Entities` и устанавливаем соответствующие разрешения.

- Переходим на вкладку `User interface`и устанавливаем доступ к нужным экранам

- На вкладке `Specific` нужно разрешить доступ для `ui.loginToUi`, но лучше добавить использовать стандартную роль **UiMinimalRole**, в которой содержится это разрешение, а также доступ к экранм `Login` и `Main`

Назначение ролей происходит в приложении

### Создание роли уровня строк

- Политика JPQL определяет JPQL-запрос с условием `WHERE` и, опционально, `JOIN`, который будет применяться при загрузке данных, которые будут отфильтрованы на уровне БД

```
{E}.createdBy = :current_user_username
```

- Предикатная политика, в свою очередь, объявляет некоторую логическую функцию, которая вызывается перед выполнением операции над сущностью

```
(entity) -> !entity.getConfidential()

```

Роли уровня строк работают совместно с ресурсными ролями, не имея которых будет нечего ограничивать.

> Создадим роль, ограничивающую менеджера его проектом.

`+` > `Row-level Role`

Студия сгенерирует код интерфейса с аннотацией `@RowLevelRole`

Добавим предикатную политику `Add Policy` > `Predicate Policy` для сущности `Project` с операциями `DELETE` и  `UPDATE`

Студия сгенерирует код метода с аннотацией `@PredicateRowLevelPolicy`. Этот метод может возвращать значение типа `RowLevelPredicate`, но если в предикате необходимо получить доступ к бинам Spring, тип должен быть `RowLevelBiPredicate`.

Во вставленые метод прописываем логику сравнения текущего пользователя и менеджера сравнения.

В запущенном приложении добавляем созданную роль к менеджеру, таким образом корректирую его разрешения.

```java
    @PredicateRowLevelPolicy(entityClass = Project.class, actions = {RowLevelPolicyAction.UPDATE, RowLevelPolicyAction.DELETE})
    default RowLevelBiPredicate<Project, ApplicationContext> projectPredicate() {
        return (project, applicationContext) -> {
            CurrentAuthentication currentAuthentication = applicationContext.getBean(CurrentAuthentication.class);
            User currentUser = (User) currentAuthentication.getUser();
            return currentUser.equals(project.getManager());
            // Если значение текущий юзер является менеджером проекта, предикат возвратит значение true и операции, перечисленные в аннотации будут разрешены
        };
    }
```
Роль уровня строк может содержать несколько политик.

> Создадим роль уровня строки, которая ограничивает просмотр экземпляров `TimeEntry`. Их может увидеть только сам автор или менеджер соответствующего проекта.

```java
@RowLevelRole(name = "RestrictedTimeEntriesRole", code = RestrictedTimeEntriesRole.CODE)
public interface RestrictedTimeEntriesRole {
    String CODE = "restricted-time-entries-role";
}
```

Добавим JPQL политику `Add Policy` > `JPQL Policy` для сущности `TimeEntry`. В представленной форме достаточно заполнить поле для оператора WHERE `Where clause`

```
{E}.user.username=:current_user_username or {E}.task.project.manager=:current_user_name
```

### Создание комбинированных ролей

Комбинировать роли можно как из программы. 

Второй способ комбинировать роли - создать новую роль(интерфейс) через контекстное меню пункта `Security` наследовать интерфейсы созданных ранее ролей:

```java
@ResourceRole(name = "CombinedProjectManagerRole", code = CombinedProjectManagerRole.CODE)
public interface CombinedProjectManagerRole extends ProjectManagerRole, UiMinimalRole{
    String CODE = "combined-project-manager-role";
}

```


