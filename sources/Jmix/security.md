# Подсистема безопасности.

Определение ролей в коде происходит с помощью аннотированных интерфейсов. Студия предоставляет визуальный редактор и код может быть сгенерирован автоматически.

Центральным элементом подсистемы является пользователь `User`.

### Встроенные пользователи

`Admin`

Содержится в новом проекте по умолчанию. Имеет роль полного доступа FullAccesRole и обладает всеми разрешениями. Хранится в базе данных.

`Anonymous`

Соответствует не прошедшим аутентификацию пользователям. Позволяет пользователю некоторые разрешения до того, как он войдёт в систему. По умолчанию не имеет никаких разрешений.

`System` 

Требуется для механизма системной аутентификации, когда с приложением взаимодействует некоторый сервис.

### Получение и работа с текущим пользователем.

Для определения из кода программы, какой пользователь аутентифицирован, служат методы, определённые в интерфейсе `CurrentAuthentication`.

Например: добавим автозаполнение поля `User` при инициализации экрана `TimeEntryDetailView`.

Добавим в контроллер код, определяющий текущего пользователя используя `Code Snippets` -> `Get current user`.

```java
public class TimeEntryDetailView extends StandardDetailView<TimeEntry> {

    @Autowired
    private CurrentAuthentication currentAuthentication;

    @Subscribe
    public void onInitEntity(final InitEntityEvent<TimeEntry> event) {
        event.getEntity().setEntryDate(LocalDateTime.now());
        final User user = (User) currentAuthentication.getUser();
        event.getEntity().setUser(user);
    }
}
```

### Роли и политики

Роли в Jmix — это наборы политик, которые предоставляют пользователям доступ к различным ресурсам в приложении Jmix. Они позволяют ограничить доступ пользователей к минимально необходимой части функциональности. Пользователь без ролей не имеет разрешений и не сможет получить доступ к системе.

В приложении Jmix пользователю может быть присвоено несколько ролей двух различных типов: `ресурсных ролей` и `ролей уровня строк`.

Ресурсные роли являются позитивными, разрешающими.

Роли уровня строк являются негативными, запрещающими.

Разрешения и ограничения разных политик складываются.

### Встроенные роли. UI: minimal access

Jmix и его аддоны имеют свои встроенные роли. Одной из важнейших является минимальная роль пользовательского интерфейса `UI: minimal access`. Она содержит разрешения на основные ресурсы пользовательского интерфейса Jmix.

Эта роль должна быть назначена любому пользователю, которому требуется доступ к пользовательскому интерфейсу приложения. Существуют также ряд пользователей, которым такой доступ не требуется. Например, те, которые получают доступ к приложению через REST API или настраиваемые веб-сервисы.

Роли различают по уровню детальности:

- `Крупномасштабная` включают все типы привелегии, необходимые конкретному типу 

- `Детализированная` определяют одну функциональность

- `Комбинированная` включают несколько детализированных. Из них могут составлены более крупномасштабные роли.

> Рекомендуется создавать детализированные роли во время разработки и использовать UI приложения только для их объединения в различные крупномасштабные роли для простого назначения пользователям и для редких специальных изменений в модели безопасности.

### Создание ресурсной роли

`+` > `ResourceRole`

В результате будет создан и открыт в редакторе файл *.java

Внизу находится панель редактора ролей.

Переходим на вкладку `Entities` и устанавливаем соответствующие разрешения.

Переходим на вкладку `User interface`и устанавливаем доступ к нужным экранам

### Создание роли уровня строк

Создадим роль, ограничивающую менеджера его проектом.

`+` > `Row-level Role`

Добавим предикатную политику `Add Policy` > `Predicate Policy` для сущности `Project` с операциями `DELETE` и  `UPDATE`

Во вставленые метод прописываем логику сравнения текущего пользователя и менеджера сравнения.

В запущенном приложении добавляем созданную роль к менеджеру, таким образом корректирую его разрешения.

```java
    @PredicateRowLevelPolicy(entityClass = Project.class, actions = {RowLevelPolicyAction.UPDATE, RowLevelPolicyAction.DELETE})
    default RowLevelBiPredicate<Project, ApplicationContext> projectPredicate() {
        return (project, applicationContext) -> {
            CurrentAuthentication currentAuthentication = applicationContext.getBean(CurrentAuthentication.class);
            User currentUser = (User) currentAuthentication.getUser();
            return currentUser.equals(project.getManager());
        };
    }
```
Роль уровня строк может содержать несколько политик.


