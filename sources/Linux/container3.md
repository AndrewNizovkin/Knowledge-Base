# Введение в Docker.

[Методичка](https://gbcdn.mrgcdn.ru/uploads/asset/4924994/attachment/194d8159933c69264fcc852167eefd80.pdf)

- Docker - это платформа, предназначенная для быстрой разработки,
развертывания, тестирования и запуска приложений в контейнерах и может быть использована во многих командах при разработке ПО.
    
    
 - CI/CD (Continuous Integration/Continuous Delivery) — методология разработки программного обеспечения, которая обеспечивает надежность и скорость создания продукта. Относится к одной из типовых DevOps-практик.
 
 ```bash
# Выводит версию докера
docker --version
docker info

# Выводит список image.id
docker images -aq 

# Удаляет все остановленные образы.
# Флаг -a говорит вывести, в том числе, остановленные контейнеры,
# а флаг -q говорит о том, что вывести необходимо ID
# контейнеров.
docker rmi $(docker images -aq) -f

# запускает контейнер ubuntu в интерактивном режиме
docker run -it ubuntu bash
docker run -it ubuntu date 

# выводит информацию о занимаемой памяти
docker system df

# очищает систему. Удаляет остановленные контейнеры и неиспользуемые
# образы
docker system prune -af

# чистка, включая неиспользуемые volume и весь build cache
docker system prune -a --volumes

# Удалить все остановленные контейнеры
docker container prune

# Удалить все неиспользуемые образы
docker image prune -a

# удалить все неиспользуемые volume
docker volume prune



# устанавливает программу ip
apt install iproute2

# запуск контейнера в интерактивном режиме
docker exec -it <id> bash

# список образов
docker image ls

# список контейнеров
docker container ls

# список виртуальных дисков
docker volume ls

# Запуск phpMyAdmin и связь его с уже запущенным контейрером с базой данных
docker run --name phpmyadmin1 --link dbcontainer-name:db -p 8080:80 phpmyadmin/phpmyadmin
 ```

Как говорится: профилактика — лучшее лечение, поэтому вот несколько профилактических советов:

- Сделайте привычкой удалять контейнер после его остановки, если он больше не нужен: docker run --rm ....

- Настройте CI/CD-пайплайны на очистку после себя.

- Для критически важных систем рассмотрите хранение данных Docker на отдельном разделе или диске. 

### Проблемы с правами доступа из контейнера на хосте.

Вы монтируете директорию с хоста в контейнер с помощью volumes, и ваше приложение внезапно начинает жаловаться на невозможность создать файл, прочитать конфиг или записать в лог. 

Корень проблемы: Внутри контейнера работают процессы от определенного пользователя (часто root по умолчанию, но в лучших практиках — непривилегированный пользователь, например, с UID=1000). Файлы же на хост-машине принадлежат вашему пользователю (также, например, с UID=1000). Если UID пользователя в контейнере не совпадает с UID владельца файла на хосте, возникают пермишны (permissions).

Это не проблема, пока контейнер работает от root (он может всё), но с точки зрения безопасности это плохая практика. Как только вы переходите на непривилегированного пользователя внутри контейнера, мир рушится.

Есть несколько вариантов решения проблемы:

Конечно же можно сразу применить грубую силу и запустить контейнер от root. Это работает, но сводит на нет одну из ключевых мер безопасности контейнеризации. Сразу скажу, что для продакшена так делать не рекомендуется.

Как вариант можно изменить права на хосте (хак). Вручную изменить владельца или права (chmod или chown) монтируемой директории на хосте так, чтобы пользователь из контейнера имел к ним доступ. Это небезопасно и не масштабируется.

 Самым честным методом решения этой проблемы будет «подогнать» пользователя внутри контейнера под вашу среду. Для этого нужно:

- Узнать ваш UID на хосте: 

    ```bash
    id -u
    ```

- В своем Dockerfile создайте пользователя с таким же UID. Это ключевой момент.

```yaml
FROM ubuntu:22.04

# ... ваши шаги ...

# Создаем группу и пользователя с конкретным UID (например, 1000)
RUN groupadd -g 1000 myappuser && \
    useradd -u 1000 -g 1000 -m myappuser

# Переключаемся на этого пользователя
USER myappuser

# Далее ваши команды, которые будут выполняться от myappuser
CMD ["python", "app.py"]
```

Теперь, при монтировании volume, файлы вашего пользователя на хосте (с UID=1000) и пользователя в контейнере (также с UID=1000) будут «видеть» друг друга как свои, и проблемы с правами исчезнут.

### Сетевые проблемы между контейнерами

Вы запускаете два контейнера: `app` и `database`. Приложение пытается подключиться к БД по адресу `localhost:5432` и получает отказ. Почему?

Всё потому, что по умолчанию каждый контейнер изолирован в своей собственной сетевой области видимости (network namespace). У него свой `localhost`, и он не видит другие контейнеры. Концепция `localhost` внутри контейнера ограничена этим контейнером.

Проблему будем решать при помощи сети Docker. Docker предоставляет встроенный механизм для организации общения контейнеров — пользовательские сети (user-defined networks).

Для начала создадим свою сеть: 

```bash
docker network create my_app_network
```
Затем запускаем БД и контейнеры в этой сети:

```bash
# Запускаем БД

docker run -d --name database --network my_app_network postgres:15

# Запускаем приложение

docker run -d --name app --network my_app_network -p 80:5000 my-app-image
```
 
Что это даёт?

- DNS-резолвинг по имени: самое главное — Docker встроил в эти сети DNS. Теперь вашему приложению в контейнере app не нужно знать IP-адрес контейнера database (который может меняться). Достаточно использовать его имя в качестве хоста.
В коде приложения строка подключения к БД изменится с localhost:5432 на database:5432. Docker автоматически преобразует имя database в правильный IP-адрес.

- Изоляция: вы можете иметь несколько окружений (dev, stage) в разных сетях, и они не будут мешать друг другу.

Да и вообще в отличие от устаревшего подхода с `--link`, сети `Docker` — это современный, гибкий и рекомендуемый способ организации взаимодействия контейнеров.

Вообще, понимать внутреннее устройство Docker, его систему хранения, модель безопасности и сетевую модель очень полезно. Этот навык позволит вам не вечно тушить разгорающиеся вновь и вновь пожары, а строить стабильные и предсказуемые системы.