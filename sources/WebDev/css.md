# CSS Каскадные таблицы стилей

## Селекторы

**Селектор** это конструкция, которая показывает к каким тегам будет применено **CSS правило**

```css
strong {
    color: red;
}
```

[Селекторы CSS](https://html5css.ru/cssref/css_selectors.php)

[Свойства CSS](https://html5css.ru/cssref/default.php)

---

Стили для элементов HTML-документа могут быть заданы различным способом:

- <span style="color:yellow;"><b>Встроенные</b></span>. Для любого элемента в начальном теге:

```html
<p style="background-color:lightblue;color:white;text-align:center;">Hello World</p>

```

- <span style="color:yellow;"><b>Внутренние</b></span>. Для каждой страницы в разделе <head> в секции <style></style>

```html
<head>
    <style>
        p {
            background-color: lightblue;
            color: white;
            text-align: center;
        }
    </style>
</head>

```

- <span style="color:yellow;"><b>Внешние</b></span>. Стили описываются в файлах *.css, которые подключаются в теле заголовка в теге <link>

```html
<head>
  <link rel="stylesheet" type="text/css" href="styles.css">
</head>
```

CSS-файл это текстовый файл, в котором для каждого селектора определяется массив `свойство: значение`

```css
h1 {
    color: blue;
    font-family: verdana;
    font-size: 300%;
}
p  {
    color: red;
    font-family: courier;
    font-size: 160%;
}
```


Если некоторые свойства были определены для одного и того же селектора (элемента) в разных таблицах стилей, будет использовано значение из последней таблицы стилей чтения.

Для определения стиля к элементу могут применяться различные селекторы, и важность каждого селектора оценивается в баллах. Чем больше у селектора пунктов, тем он важнее, и тем больший приоритет его стили имеют над стилями других селекторов. Если селектор является составным, то происходит сложение баллов всех входящих в селектор подселекторов.

|Важность|Селекторы|
|-|-|
|1|Селекторы тегов|
|10|Селекторы классов, атрибутов и псевдоклассов|
|100|Селекторы идентификаторов|
|1000|Встроенные inline-стили (задаваемые через атрибут style)|

CSS предоставляет возможность полностью отменить значимость стилей. Для этого в конце стиля указывается значение `!important`:

```css
a {font-size: 18px; color: red !important;}
#menu a {color: navy;}
```

В этом случае вне зависимости от наличия других селекторов с большим количеством баллов к ссылкам будет применяться красный цвет, определяемый первым стилем.

---

Свойства, определённые для родительского тега, наследуются потомками.

```css
/* выберет все теги p, которые расположены внутри div на первом уровне */
div > p {
    font-style: italic;
}

/* Выберет всех потомков div */
div p {
    font-style: italic;
}
```


## Псевдоклассы

В дополнение к селекторам тегов, классов и идентификаторов нам доступны селекторы псевдоклассов, которые несут дополнительные возможности по выбору нужных элементов.

|Псевдокласс|Назначение|
|-|-|
|:link|применяется к ссылкам и представляет ссылку в обычном состоянии, по которой еще не совершен переход|
|:visited|представляет ссылку, по которой пользователь уже переходил|
|:active|представляет ссылку в тот момент, когда пользователь осуществляет по ней переход|
|:hover|представляет элемент, на который пользователь навел указатель мыши. Применяется преимущественно к ссылкам, однако может также применяться и к другим элементам, например, к параграфам|
|:focus|представляет элемент, который получает фокус, то есть когда пользователь нажимает клавишу табуляции или нажимает кнопкой мыши на поле ввода (например, текстовое поле)|
|:is|применяется для сокращения длинных селекторов. Функция псевдокласса `:is()` принимает список селекторов для выбора элементов html.|
|:where|работает подобно `:is()`, он также принимает набор селекторов и выбирает все соответстующие селекторы.|

---

> Псевдокласс :is() применяет каскадность стилей (selector specificity), которая определяется по селектору с самым большим рангом. А для стилей псевдокласса :where() ранг селекторов всегда равен 0.

    
```html
    <!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Псевдоклассы в CSS3</title>
        <style>
            a:link    {color:blue; text-decoration:none}
            a:visited {color:pink; text-decoration:none}
            a:hover   {color:red; text-decoration:underline}
            a:active  {color:yellow; text-decoration:underline}
            input:hover {border:2px solid red;}
        </style>
    </head>
    <body>
        <a href="index.html">Учебник по CSS3</a>
        <input type="text" />
    </body>
</html>
```

```css
    /* header > p, main > p, footer > p {font-size: 18px; font-family: Verdana;} альтернативный вариант без :is*/
    :is(header, main, footer) > p  {font-size: 18px; font-family: Verdana;}
    :where(header, main, footer) > p  {font-size: 18px; font-family: Verdana;}
```

## Псевдоэлементы

Псевдоэлементы обладают рядом дополнительных возможностей по выбору элементов веб-страницы и похожи на псевдоклассы. Список доступных псевдоэлементов:

|Псевдоэлемент|Назначение|
|-|-|
|::first-letter|позволяет выбрать первую букву из текста|
|::first-line| стилизует первую строку текста|
|::before|добавляет сообщение до определенного элемента|
|::after|добавляет сообщение после определенного элемента|
|::selection|выбирает выбранные пользователем элементы|

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Псевдоклассы в CSS3</title>
        <style>
            .warning::before{ content: "Важно! "; font-weight: bold; }
            .warning::after { content: " Будьте осторожны!"; font-weight: bold;}
        </style>
    </head>
    <body>
        <p><span class="warning">Не пытайтесь засунуть язык в электрическую розетку.</span></p>
    </body>
</html>
```

## Селекторы атрибутов

> Применяются не только к элементам, но и к классам и идентификаторам

```css
input[type="text"]{
     
    border: 2px solid red;
}
/* в скобках значение атрибута */
```

Специальные символы позволяют конкретизировать значение атрибута:

|Символ|Предназначение|
|-|-|
|^|позволяет выбрать все атрибуты, которые начинаются на определенный текст|
|$|позволяет выбрать все атрибуты, которые заканчиваются определённым текстом|
|*|позволяет выбрать все элементы с атрибутами, которые в своем значении имеют определенный текст (не важно где - в начале, середине или конце)|

---

```css
a[href^="https://"]{
             
    color: red;
}

img[src$=".jpg"]{
             
    width: 100px;
}

a[href*="microsoft"]{
             
    color: red;
}
```

---

## Свойства текста

|свойство|назначение|
|-|-|
|font-size|размер шрифта|
|font-weight|жирность начертания (число, кратное 100 от 100 до 900)|
|font-style|стиль начертания (italic, bold, normal, oblique)|
|color|цвет текста|
|font-family|гарнитура шрифта (serif, sans-serif, arial)|
|line-height|междустрочный интервал|
|text-decoration|подчёркнутый, надчёркнутый, перечёркнутый (underline, overline, line-throught)|
|text-transform|заглавные, строчные (uppercase, lowercase)|
|text-align|выравнивание текста (left, right, center, justify-по ширине)|
|text-indent|задаёт отступ первой строки обзаца в `em` или `px`|
|text-shadow|создаёт тени для текста|

---

```css
h1 {
    text-shadow: 5px 4px 3px #999;
    /* гор_смещение верт_смещение степень_размытости цвет_тени */
}
```

---

## Свойства списков

- list-style-type - тип маркера
    
    - неупорядоченные списки
    
        - disc
    
        - circle
    
        - square
    
    - нумерованные списки
    
        - decimal - арабские
    
        - lower-roman - стр. римские
    
        - upper-roman - загл. римские
    
        - lower-alpha - стр. латинские буквы
    
        - upper-alpha- загл. латинские буквы

- list-style-image - устанавливает любую картинку

    ```css
    list-style-image: url("images/image.png")
    ```

- list-stile-position - положение маркера списка

    - outside - положение снаружи (по умолчанию)
    - inside - внутри

---

## Стилизация таблиц

|свойство|назначение|
|-|-|
|border|устанавливает толщину, тип и цвет границ|
|border-collapse| устанавливает, как будет стилизоваться граница смежных ячеек|
|border-spacing|устанавливает промежутки между границами смежных ячеек, если смежные ячейки имеют раздельные границы|
|caption-side|устанавливает положение элемента caption|
|empty-sells|задает режим отрисовки для пустых ячеек|
|table-layout|определяет размеры таблицы|
|vertical-align|определяет вертикальное содержимое ячеек. Применяется только к элементам `<th>` и `<td>`|

---

```css
table {
    border: 1px solid #ccc;  /* граница всей таблицы */
}
tr {
    border: 1px solid #ccc;  /* границы между строками */
}
td, th {
    border: 1px solid #ccc;  /* границы между столбцами */
}
```

|border-collapse:|результат|
|- |-|
|collapse|смежные ячейки имеют общую границу|
|separate|смежные ячейки имеют отдельные границы, которые разделяются пространством|

---

|empty-cells:|результат|
|-|-|
|show|пустые ячейки отображаются, значение по умолчанию|
|hide|пустые ячейки не отображаются|

---

|caption-side:|результат|
|-|-|
|top|позиционирование заголовка вверху (значение по умолчанию)|
|bottom|позиционирование заголовка внизу|

---

|table-layout:|результат|
|-|-|
|auto|браузер устанавливает ширину столбцов автоматически, исходя из ширины самой широкой ячейки в столбце. А из ширины отдельных столбцов складывается ширина всей таблицы (по умолчанию)|
|fixed|позволяет установить фиксированную ширину|

```css
table {
    border: 1px solid #ccc;
    border-spacing: 3px;
    table-layout: fixed;
    width:350px; 
}
```

|vertical-align|результат|
|-|-|
|top|выравнивание содержимого по верху ячейки|
|baseline|выравнивание первой строки текста по верху ячейки|
|middle|выравнивание по центру (значение по умолчанию)|
|bottom|выравнивание по низу|

---

## Стилизация элемента `details`

### Атрибут `open`

Прежде всего в раскрытом состоянии к элементу `details` добавляется атрибут `open`. Соответственно, используя атрибут, можно задать разные стили для элемента в скрытом и раскрытом состоянии. Например:

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>METANIT.COM</title>
    <style>
    details > summary {
        padding: 5px;
        background-color: #eee;
        color: #333;
        border: 1px #ccc solid;
        cursor: pointer;
    }
 
    details > div {
        border: 1px #ccc solid;
        padding: 10px;
    }
    details[open] > summary {
        color:#eee; 
        background-color:#333;
    }
</style>
</head>
<body>
<details>
    <summary>Князь Андрей и Пьер в Богучарово</summary>
    <div>Вокруг дома был рассажен молодой сад. Ограды и ворота были прочные и новые; под навесом 
    стояли две пожарные трубы и бочка, выкрашенная зеленою краской; дороги были прямые, мосты были крепкие с перилами. 
    На всем лежал отпечаток аккуратности и хозяйственности.</div>
</details>
</body>
</html>
```

С помощью селектора `details[open]` мы можем обратиться к элементу `details` в раскрытом состоянии. Соответственно, показаный ниже селектор Позволяет задать стили для элемента `summary` в раскрытом состоянии.

```css
details[open] > summary {
    color:#eee; 
    background-color:#333;
}
```

### Настройка маркера

По умолчанию элемент `summary` в качестве маркера скрытости/раскрытости использует символ треугольника. Но его также можно настроить.

Для настройки изображения маркера можно использовать свойство `list-style`, а также дополнительные свойства типа `list-style-type` или `list-style-image`, которые применяются для стилизации списков. Например, если необходимо убрать этот маркер, то можно применить стиль `list-style: none`:

```css
details > summary {
    padding: 5px;
    background-color: #eee;
    color: #333;
    border: 1px #ccc solid;
    cursor: pointer;
    list-style: none;
}
 ```

### Настройка с помощью свойства `content`

```css
summary:before {
   content: "+";
   font-size: 20px;
   font-weight: bold;
   margin: -5px 5px 0 0;
}
 
details[open] summary:before {
   content: "-";
}
```

В данном случае с помощью селектора `summary:before` устанавливаем содержимое, которое будет располагаться перед основным содержимым элемента `summary`. Селектор `details[open] summary:before` позволяет сделать то же самое, только в раскрытом виде. В итоге в скрытом виде маркер будет отображать символ `+`, а в раскрытом - символ `-`

### CSS-свойство `cursor`

CSS-свойство cursor устанавливает курсор мыши, если таковой имеется, для отображения, когда указатель мыши находится над элементом.

Внешний вид курсора помогает информировать пользователей об операциях, которые можно выполнять при взаимодействии с элементом.

Для внешнего вида курсора можно использовать ключевое слово (`keyword`) или задать пользовательское изображение. В качестве запасного варианта можно указать несколько url() на случай, если некоторые типы изображений курсора не поддерживаются. Резервный вариант, отличный от URL-адреса (одно или несколько ключевых слов), должен находиться в конце резервного списка.

```css
/* Ключевое слово: */
cursor: pointer;

/* URL */
cursor: url(hand.cur), pointer;
```

Некоторые доступные ключевые слова:

|значение|описание|
|-|-|
|auto|Браузер самостоятельно определяет значение курсора в зависимости от свойств элемента, на который наведена мышь.|
|default|Основной курсор платформы, обычно стрелочка.|
|none|Курсор не отображается|
|pointer|Указатель, обозначающий ссылку, обычно указующая рука.|
|wait|Программа занята (песочные часы).|
|progress|Программа занята, но пользователь может взаимодействовать с интерфейсом (в отличие от wait).|
|cell|Указывает на возможность выбора клетки или клеток таблицы.|
|crosshair|Крестик, часто используемый для обозначения выбора на битовой карте|
|text|Значок выбора текста.|
|zoom-in|Увеличение|
|zoom-out|Уменьшение|
|grab|Указывает на возможность схватить и переместить объект (рука).|

## Цвет в CSS

Цвет можно задать следующими способами:

- в виде 16-ричного кода

    ```css
    color: #000000;
    color: #ffffff;
    color: #ff00ff;
    ```

- в rgb-формате, воспользовавшись функцией rgb(r, g, b)

    ```css
    color: rgb(0, 0, 0);
    ```
- в rgba-формате, задав прозрачность (0.0 - 1.0)

    ```css
    color: rgba(0, 0, 0, 0.5);
    color: rgba(255, 0, 255, 0.2);
    ```

---

## Блочная модель

![block-model](./images/blok-model.png)

Для веб-браузера элементы страницы представляют небольшие контейнеры или блоки. Такие блоки могут иметь различное содержимое - текст, изображения, списки, таблицы и другие элементы. Внутренние элементы блоков сами выступают в качестве блоков.

Пусть элемент расположен в каком-нибудь внешнем контейнере. Это может быть элемент `body`, `div` и так далее. От других элементов он отделяется некоторым расстоянием - внешним отступом, которое описывается свойством CSS `margin`. То есть свойство `margin` определяет расстояние от границы текущего элемента до других соседних элементов или до границ внешнего контейнера.

Далее начинается сам элемент. И в начале идет его граница, которая в CSS описывается свойством `border`.

После границы идет внутренний отступ, который в CSS описывается свойством `padding`. Внутренний отступ определяет расстояние от границы элемента до внутреннего содержимого.

Далее идет внутреннее содержимое, которое также реализует ту же блочную модель и также может состоять из других элементов, которые имеют внешние и внутренние отступы и границу.

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Блочная модель в CSS3</title>
        <style>
            div{
                margin: 15px; /* внешний отступ */
                padding: 11px; /* внутренний отступ */
                border: 3px solid red; /* границы шириной в 3 пикселя сплошной красной линией */
            }
        </style>
    </head>
    <body>
        <div>
            <p>Первый блок</p>
        </div>
        <div>
            <p>Второй блок</p>
        </div>
    </body>
</html>
```

Свойство `margin` определяет отступ элемента от других элементов или границы внешнего контейнера. Существуют специальные свойства CSS для задания отступов для каждой стороны:

|свойство|назначение|
|-|-|
|margin-top|отступ сверху|
|margin-bottom|отступ снизу|
|margin-left|отступ слева|
|margin-right|отступ справа|

---

```css
div{
    margin-top: 30px; /* отступ сверху */
    margin-left: 25px; /* отступ слева */
    margin-right: 20px; /* отступ справа */
    margin-bottom: 15px; /* отступ снизу */
    /* можно одним свойством: */
    /* margin: 30px 20px 15px 25px;              */
    border: 3px solid red; /* граница */
}
```

Для установки отступов можно использовать точные значения в пикселях (px) или em, либо процентные отношения, либо значение auto (автоматическая установка отступов).

При использовании процентов веб-браузеры вычисляют размер отступов на основе ширины элемента-контейнера, в который заключен стилизуемый элемент.

В то же время, если несколько элементов у нас соприкасаются, то браузер выбирает наибольший отступ элемента, который затем и используется. Так, выше в примере использовался следующий стиль:

Свойство `padding` задает внутренние отступы от границы элемента до его внутреннего содержимого. Как и для свойство margin, в CSS имеются четыре свойства, которые устанавливают отступы для каждой из сторон:

- padding-top

- padding-bottom

- padding-left

- padding-right

---

Для настройки границы могут использоваться сразу несколько свойств:

|свойство|назначение|
|-|-|
|border-width|ширина границы|
|border-style|стиль линии границы|
|border-color|цвет границы|
|border-radius|позволяет округлить границу. Это свойство принимает значение радиуса в пикселях или единицах em.|

---

Свойство `border-width` может принимать следующие типы значений:

- Значения в единицах измерения, таких как em, px или cm

- Одно из константных значений: `thin` (тонкая граница - 1px), `medium` (средняя по ширине - 3px), `thick` (толстая - 5px)

|border-style:||
|-|-|
|none|граница отсутствует|
|solid|граница в виде обычной линии|
|dashed|штриховая линия|
|dotted|линия в виде последовательности точек|
|double|граница в виде двух параллельных линий|
|groove|граница имеет трехмерный эффект|
|inset|граница как бы вдавливается во внутрь|
|outset|аналогично inset, только граница как бы выступает наружу|
|ridge|граница также реализует трехмерный эффект|

---

Для установки границы для отдельных сторон можно использовать одно из свойств:

- border-top

- border-bottom

- border-left

- border-right

---

При необходимости мы можем определить цвет, стиль и ширину границы для каждой из сторон используя следующие свойства:

- border-top-width

- border-top-style

- border-top-color

- border-bottom-width

- .......

---

Так как у элемента может быть максимально черыре угла, можно указать четыре значения для установки радиуса у каждого из углов:

```css
border-radius: 15px 30px 5px 40px
```

Для установки радиусов углов по отдельности используются свойства:

```css
border-top-left-radius: 15px;   /* радиус для верхнего левого угла */
border-top-right-radius: 30px;  /* радиус для верхнего правого угла */
border-bottom-right-radius: 5px;    /* радиус для нижнего левого угла */
border-bottom-left-radius: 40px;    /* радиус для нижнего правого угла */
```

Для создания элиптических углов:

```css
border-radius: 40px/20px;
```

## Размеры элементов

### Единицы измерения

Значение по умолчанию для этих свойств - auto, то есть браузер сам определяет ширину и высоту элемента. Можно также явно задать размеры с помощью единиц измерения (пикселей, em) или с помощью процентов:

|единица|значение|
|-|-|
|px|пиксель, минимальная точка экрана|
|em|размер шрифта родителя|
|rem|размер относительно размера шрифта элемента `<html>` (не поддерживается IE8-)|
|%|размер относительно того же свойства родителя или контейнера|

---

Для поддержки мобильных устройств были созданы размеры относительно экрана (кроме IE8-)

|единица|значение|
|-|-|
|vw|1% ширины окна|
|vh|1% высоты окна|
|vmin|наименьшее из (vw, vh), в IE9 обозначается vm|
|vmax|наибольшее из (vw, vh)|

---

Размеры элементов задаются с помощью свойств `width` (ширина) и `height` (высота). Значение по умолчанию для этих свойств - `auto`, то есть браузер сам определяет ширину и высоту элемента. 

Следует помнить что `width` определяет ширину  внутреннего содержимого элемента, а под блок самого элемента будет выделяться пространство, ширина которого равна ширине внутреннего содержимого (свойство `width`) + внутренние отступы (свойство `padding`) + ширина границы (свойство `border-width`) + внешние отступы (свойство `margin`). 

С помощью дополнительного набора свойств можно установить минимальные и максимальные размеры:

|свойство|назначение|
|-|-|
|min-width|минимальная ширина|
|max-width|максимальная ширина|
|min-height|минимальная высота|
|max-height|максимальная высота|

```css
min-width: 200px;
width:50%;
max-width: 300px;
/* В данном случае ширина элемента равна 50% ширины элемента-контейнера, однако при этом не может быть меньше 200 пикселей и больше 300 пикселей.
 */
```

### Переопределение ширины блока

Свойство `box-sizing` позволяет переопределить установленные размеры элементов. Оно может принимать одно из следующих значений:

|box-sizing:|результат|
|-|-|
|content-box|начение свойства по умолчанию, при котором браузер для определения реальных ширины и высоты элементов берет соответственно значения свойств `width` и `height` элемента|
|padding-box|указывает веб-браузеру, что ширина и высота элемента должны включать внутренние отступы как часть своего значения. (большинство современных браузеров не поддерживают данное свойство.)|
|border-box|указывает веб-браузеру, что ширина и высота элемента должны включать внутренние отступы и границы как часть своего значения.|

---

## Свойства фоновых изображений элемента

- `backgraund-color` - цвет фона

- `background-image` - фоновое изображение

    ```css
    background-image: url(images/image.jpg);
    ```
- `background-size` - устанавливает размер фонового изображения либо единицы измерения, либо одно из предустановленных значений:

    - `contain` - масштабирует изображение по наибольшей стороне, сохраняя аспектное отношение

    - `cover` - масштабирует изображение по наименьшей стороне, сохраняя аспектное отношение

    - `auto` - значение по умолчанию, изображение отображается в полный размер

Можно задать точное значение для одного измерения - ширины или высоты, а для другого задать автоматические размеры, чтобы браузер сам выводил точные значения:

```css
background-size: 200px auto;
```

- `background-attachment` - устанавливает стиль прикрепления фонового изображения к элементу:

    - `fixed` - фон элемента фиксирован вне зависимости от прокрутки внутри элемента

    - `local` - по мере прокрутки внутри элемента фон изменяется

    - `scroll` - фон фиксирован и не меняется при прокрутке, но в отличие от fixed несколько элементов могут использовать свой фон, тогда как при fixed создается один фон для всех элементов

- `background-origin` - устанавливает начальную позицию фонового изображения

    - `border-box` - он у элемента устанавливается начиная с его внешней границы, определяемой свойством `border`

    - `padding-box` - устанавливается с учетом внутренних отступов

    - `content-box` - фон устанавливается по содержимому элемента

- `background-clip` - определяет, какая часть изображения используется для фона

    - `border-box` - изображение обрезается по границам элемента

    - `padding-box` - из изображения исключается та часть, которая находится под границами элемента

    - `content-box` - изображение обрезается по содержимому с учетом внутренних отступов

- `backgraund-repeat` - повторение изображения
    
    - `no-repeat` - не повторяется
    
    - `repeat-x` - повторение по горизонтали

    - `repeat-y` - повторение по вертикали

    - `repeat` - повторение по обеим сторонам (по умолчанию)

    - `space` - изображение повторяется для заполнения всей поверхности элемента, но без создания фрагментов

    - `round` - изображение должным образом масштабируется для полного заполнения всего пространства

- `background-position` - положение фонового изображения внутри элемента. Оно может принимать отступы от верхнего левого угла элемента в единицах измерения, например, в пикселях в следующем формате:

    ```css
    background-position: отступ_по_оси_X отступ_по_оси_Y;   

    ```

    Кроме того, данное свойство может принимать одно из следующих значений:

    - `top`

    - `bottom`

    - `left`

    - `right`

    - `center`

- `background` - по сути является сокращением всех ранее рассмотренных свойств CSS в формате:

```css
background: <background-color> <background-position> <background-size>
<background-repeat> <background-origin> <background-clip> <background-attachment>
<background-image>
```

---

## Создание тени у элемента

Свойство box-shadow позволяет создать у элемента тень. Это свойство может принимать сразу несколько значений:

```css
box-shadow: hoffset voffset blur spread color inset
```

|значение|результат|
|-|-|
|hoffset|горизонтальное смещение тени относительно элемента. При положительном значении тень смещается вправо, а при отрицательном - влево|
|voffset|вертикальное смещение тени относительно элемента. При положительном значении тень смещается вниз, а при отрицательном - вверх|
|blur|необязательное значение, которое определяет радиус размытия тени. Чем больше это значение, тем более размытыми будут края тени. По умолчанию имеет значение 0.|
|spread|необязательное значение, которое определяет направление тени. Положительное значение распространяет тень во вне во всех направлениях от элемента, а отрицательное значение направляет тень к элементу|
|color|необязательное значение, которое устанавливает цвет тени|
|inset|необязательное значение, которое заставляет рисовать тент внутри блока элемента|
---

Через запятую можно определить несколько различных теней:

```css
box-shadow: 5px 3px 8px 3px #faa, 10px 4px 10px 3px #888 inset;
```

---

## Контуры элемента

Контуры располагаются вне элемента сразу за его границами.

Контур в CSS 3 представлен свойством `outline`, хотя данное свойство является сокращением следующих свойств:

|свойство|назначение|
|-|-|
|outline-color|цвет контура|
|outline-ofset|смещение контура|
|outline-style|стиль контура. Оно принимает те же значения, что и `border-style`|
|outline-width|толщина контура|
---

## Обтекание элементов

Свойство `float`,позволяет установить обтекание элементов

Элементы, к которым применяется свойство `float`, еще называют floating elements или плавающими элементами. 

|float:|результат|
|-|-|
|left|элемент перемещается влево, а все содержимое, которое идет ниже его, обтекает правый край элемента|
|right|элемент перемещается вправо|
---

> При применении свойства `float` для стилизуемых элементов, кроме элемента `img`, рекомендуется установить свойство `width`.

### Запрет обтекания

Иногда возникает необходимость запретить обтекания. Например, футер, как правило, должен находиться строго внизу и растягиваться по всей ширине страницы. Если же перед футером находится плавающий элемент, то футер может обтекать этот элемент, что не желательно.

Для запрета обтекания элементов в CSS применяется свойство `clear`:

|clear:|результат|
|-|-|
|left|стилизуемый элемент может обтекать плавающий элемент справа. Слева же обтекание не работает|
|right|стилизуемый элемент может обтекать плавающий элемент только слева. А справа обтекание не работает|
|both|стилизуемый элемент может обтекать плавающие элементы и относительно них смещается вниз (футер)|
|none|стилизуемый элемент ведет себя стандартным образом, то есть принимает участие в обтекании справа и слева|
---

## Прокрутка элементов

Свойство `overflow` позволяет настроить поведение блока в ситуации, когда содержимое блока занимает гораздо больше места, чем определено шириной и высотой блока и добавить возможность прокрутки. Это свойство может принимать следующие значения:

|overflow:|результат|
|-|-|
|auto|если контент выходит за границы блока, то создается прокрутка. В остальных случаях полосы прокрутки не отображаются|
|hidden|отображается только видимая часть контента. Контент, который выходит за границы блока, не отображается, а полосы прокрутки не создаются|
|scroll|в блоке отображаются полосы прокрутки, даже если контент весь помещается в границах блока, и таких полос прокрутки не требуется|
|visible|значение по умолчанию, контент отображается, даже если он выходит за границы блока|

Свойство overflow управляет полосами прокрутки как по вертикали, так и по горизонтали. С помощью дополнительных свойств overflow-x и overflow-y можно определить прокрутку соответственно по горизонтали и по вертикали. Данные свойства принимают те же значения, что и overflow:

```css
overflow-x: auto;
overflow-y: hidden;
```

## Линейный градиент

Градиенты представляют плавный переход от одного цвета к другому. В CSS3 имеется ряд встроенных градиентов, которые можно использовать для создания фона элемента.

Градиенты в CSS не представляют какого-то специального свойства. Они лишь создают значение, которое присваивается свойству `background-image`.

Линейный градиент распространяется по прямой от одного конца элемента к другому, осуществляя плавный переход от одного цвета к другому.

Для создания градиента нужно указать его начало и несколько цветов, например:

```css
background-image: linear-gradient(left,black,white);

```

В данном случае началом градиента будет левый край элемента, который обозначается значением `left`. Цвета градиента: черный (black) и белый (white). То есть начиная с левого края элемента до правого будет плавно идти переход из черного цвета в белый.

В использовании градиентов есть один недостаток - многообразие браузеров вынуждает использовать префикс вендора:

- `-webkit-` Для Google Chrome, Safari, Microsoft Edge, Opera выше 15 версии

- `-moz-`  Для Mozilla Firefox

- `-o-`  Для Opera старше 15 версии (Opera 12)

Так, полноценное использование градиента будет выглядеть следующим образом:

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Стилизация таблиц в CSS3</title>
        <style>
        div {
            width: 200px;
            height: 100px;
            background-color: #eee;
            background-image: linear-gradient(left,black,white);
            background-image: -o-linear-gradient(left,black,white);
            background-image: -moz-linear-gradient(left,black,white);
            background-image: -webkit-linear-gradient(left,black,white);
        }
        p{
            margin: 0;
            padding-top: 30px;
            text-align: center;
            color:white;
        }
        </style>
    </head>
    <body>
        <div><p>Линейный черно-белый градиент</p></div>
    </body>
</html>
```

Для установки начала градиента можно использовать следующие значения: 

|значениие|результат|
|-|-|
|left|слева направо|
|rigth|справа налево|
|top|сверху вниз|
|bottom|снизу вверх|
---

Также можно задать диагональное направление с помощью двух значений:

```css
background-image: linear-gradient(top left,black,white);
```

Кроме конкретных значений типа `top` или `left` также можно указать угол от 0 до 360, который определит направление градиента:

```css
background-image: linear-gradient(30deg,black,white);
```

Цветов не обязательно должно быть два, их может быть и больше:

```css
background-image: linear-gradient(top, red, #ccc, blue);
```

Все применяемые цвета распределяются равномерно. Однако можно также указать конкретные места фона для цветовых точек. Для этого после цвета добавляется второе значение, которое и определяет положение точки.

```css
background-image: linear-gradient(left, #ccc, red 20%, red 80%, #ccc);
```

### Повторяющийся градиент

С помощью `repeating-linear-gradient` можно создавать повторяющиеся линейные градиенты. Например:

```css
background-image: repeating-linear-gradient(left, #ccc 20px, red 30px, rgba(0, 0, 126, .5) 40px);
background-image: -moz-repeating-linear-gradient(left, #ccc 20px, red 30px, rgba(0, 0, 126, .5) 40px);
background-image: -webkit-repeating-linear-gradient(left, #ccc 20px, red 30px, rgba(0, 0, 126, .5) 40px);
```

В данном случае градиент начинается с левого края элемента с полоски серого цвета (#ccc) шириной 20 пикселей, далее до 30 пикселей идет переход к красному цвету, а затем до 40 пикселей выполняется обратный переход к светло-синему цвету (rgba(0, 0, 126, .5)). После этого браузер повторяет градиент, пока не заполнит всю поверхность элемента.

## Радиальный градиент

Радиальные градиенты в отличие от линейных распространяются от центра наружу по круговой схеме. Для создания радиального градиента достаточно указать цвет, который будет в центре градиента, и цвет, который должен быть снаружи. Эти цвета передаются в функцию `radial-gradient()`:

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Стилизация таблиц в CSS3</title>
        <style>
        div {
            width: 200px;
            height: 200px;
            border-radius: 100px;
             
            background-color: #eee;
            background-image: radial-gradient(white, black);
            background-image: -moz-radial-gradient(white, black);
            background-image: -webkit-radial-gradient(white, black);
        }
        p{
            margin: 0;
            padding-top: 60px;
            text-align: center;
            color: #eee;
        }
        </style>
    </head>
    <body>
        <div><p>Радиальный градиент</p></div>
    </body>
</html>
```

Как и в случае с линейным градиентом здесь также надо использовать префиксы вендоров для поддержки браузерами.

Радиальный градиент может иметь две формы: круговую и эллиптическую. Эллиптическая форма представляет распространение градиента в виде эллипса и задается с помощью ключевого слова `ellipse`:

```css
background-image: radial-gradient(ellipse, white, black);
```

Поскольку это значение для градиента по умолчанию, то оно может опускаться при использовании.

Круговая форма представляет распространение градиента в виде кругов от центра во вне. Для этого используется ключевое слово `circle`:

```css
background-image: radial-gradient(circle, white, black);
```

Как правило, центр радиального градиента расположен в центре элемента, но это поведение можно переопределить, указав значение для параметра `background-position`:

```css
background-image: radial-gradient(25% 30%, circle, white, black);
```

Числа 25% 30% означают, что центр градиента будет находиться на расстоянии в 25% от левой границы и в 30% от верхней границы элемента.

С помощью специальных дополнительных значений можно задать размер градиента:

|||
|-|-|
|closest-side|градиент распространяется из центра только до ближайшей к центру стороне элемента. То есть градиент остается внутри элемента|
|closest-corner|ширина градиента вычисляется по расстоянию из его центра до ближайшего угла элемента, поэтому градиент может выйти за пределы элемента.|
|farthest-side|градиент распространяется из центра до самой дальней стороны элемента|
|farthest-corner|ширина градиента вычисляется по расстоянию из его центра до самого дальнего угла элемента|
---

Пример:

```css
background-image: radial-gradient(25% 30%, circle farthest-corner, white, black);
```

## Создание макета страницы и верстка

### Блочная верстка.

Блочная верстка - это отосительно условное название способов и приемов верстки, когда в большинстве веб-страниц для разметки используется CSS-свойство `float`, а основным строительным элементов веб-страниц является элемент `<div>`, то есть по сути блок. 

При работе с элементами, которые используют обтекание и свойство `float`, важен их порядок. Так, код плавающего элемента, у которого устанавливается свойство `float`, должен идти перед элементом, который обтекает плавающий элемент. То есть блок сайдбара будет идти до блока основного содержимого.

Далее, чтобы переместить блок сайдбара влево по отношению к блоку основного содержимого и получить эффект обтекания, нам надо указать у блока сайдбара свойство float: `left` и предпочтительную ширину. Ширина может быть фиксированной, например, 150 px или 8 em. Либо также можно использовать проценты, например, 30% - 30% от ширины контейнера `body`. С одной стороны, блоками с фиксированной шириной легче управлять, но с другой процентные значения ширины позволяют создавать более гибкие, резиновые блоки, которые изменяют размеры при изменении размеров окна браузера.

Последним шагом является установка отступа блока с основным содержимым от блока сайдбара. Поскольку при обтекании обтекающий блок может обтекать плавающий элемент и справа и снизу, если плавающий элемент имеет меньшую высоту, то нам надо установить отступ, как минимум равный ширине плавающего элемента. Например, если ширина сайдбара равна 150px, то для блока основного содержимого можно задать отступ в 170px, что позволит создать пустое пространство между двумя блоками.

При этом не стоит у блока основного содержимого указывать явным образом ширину, так как браузеры расширяют его автоматически, чтобы он занимал все доступное место.



```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Блочная верстка в HTML5</title>
        <style>
            div{
                margin: 10px;
                border: 1px solid black;
                font-size: 20px;
                height: 80px;
            }
            #header{ 
                background-color: #ccc;
            }
            #sidebar{
                background-color: #ddd;
                float: left;
                width: 150px;
            }
            #main{
                background-color: #eee;
                height: 200px;
                margin-left: 170px; /* 150px (ширина сайдбара) + 10px + 10px (2 отступа) */
            }
            #footer{ 
                background-color: #ccc;
            }
        </style>
    </head>
    <body>
        <div id="header">Шапка сайта</div>
        <div id="sidebar">Сайбар</div>
        <div id="main">Основное содержимое</div>
        <div id="footer">Футер</div>
    </body>
</html>
```

Нередко встречается ситуация, когда к вложенным в обтекающий блок элементам также применяется обтекание. Например, блок основного содержимого может включать блок собственно содержимого и блок меню. В принципе к таким блокам будут применяться все те же правила, что были рассмотрены ранее.

### Выравнивание по высоте

При блочной верстке мы можем столкнуться с проблемой высоты с столбцов, которая может особенно сильно проявиться, если плавающие блоки имеют определенный фон. Рассмотрим проблему на примере: Имеем плавающий слева блок меню и блок содержимого. В случае, если блок с содержимым имеет много текста, то блок с меню имеет недостаточную высоту.

Наиболее распространенным решением данной проблемы является оборачивание плавающего элемента и блока, его обтекающего, в отдельный элемент, у которого устанавливается фон. Затем этот фон используется наименьшим по длине блоком. В итоге получается иллюзия, что блоки имеют равную длину, а фон у блоков установлен корректно.

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Блочная верстка в HTML5</title>
        <style>
            body, h2, p{
                margin:0;
                padding:0;
            }
            body{
                font-size: 18px;
            }
            #header{ 
                background-color: #eee;
                border-bottom: 1px solid #ccc;
                height: 80px;
            }
            #wrapper{
                background-color: #ddd;
            }
            #menu{
                float: left;
                width: 150px;
            }
            #main{
                background-color: #f7f7f7;
                border-left: 1px solid #ccc;
                margin-left: 150px;
                padding: 10px;
            }
            #footer{ 
                border-top: 1px solid #ccc;
                background-color: #dedede;
            }
        </style>
    </head>
    <body>
        <div id="header"><h2>Сайт MySyte.com</h2></div>
        <div id="wrapper">
            <div id="menu">
                <ul>
                    <li><a href="#">Главная</a></li>
                    <li><a href="#">Блог</a></li>
                    <li><a href="#">Контакты</a></li>
                    <li><a href="#">О сайте</a></li>
                </ul>
            </div>
            <div id="main">
                <h2>What is Lorem Ipsum?</h2>
                <p>Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum 
                    has been the industry...</p>
            </div>
        </div>
        <div id="footer">
            <p>Copyright © MySyte.com, 2016</p>
        </div>
    </body>
</html>

```

### Свойство `display`

Это свойство позволяет управлять блоком элемента и также влиять на его позиционирование относительно соседних элементов.

Принимает следующие значения:

|display:|результат|
|-|-|
|inline|элемент становится строчным, подобно словам в строке текста|
|block|элемент становится блочным, как параграф, в том числе и `span`|
|inline-block|элемент располагается как строка текста|
|list-item|элемент позиционируется как элемент списка обычно с добавление маркера виде точки или порядкового номера|
|run-in|тип блока элемента зависит от окружающих элементов|
|flex|позволяет осуществлять гибкое позиционирование элментов|
|table, inline-table|позволяет расположить элементы в виде таблицы|
|none|элемент не виден и удален из разметки html|
---

> Следует учитывать, что при применении значения `inline` браузер игнорирует некоторые свойства, такие как `width`, `height`, `margin`.

**`inline-block`** - представляет элемент, который обладает смесью признаков блочного и строчного элементов. По отношению к соседним внешним элементам такой элемент расценивается как строчный. То есть он не отделяется от соседних элементов переводом строки. Однако по отношению к вложенным элементам он рассматривается как блочный. И к такому элементу применяются свойства `width`, `height`, `margin`

**`run-in`** определяет элемент, который зависит от соседних элементов. И здесь есть три возможных варианта:

- Элемент окружен блочными элементами, тогда фактически он имеет стиль `display`: `block`, то есть сам становится блочным

- Элемент окружен строчными элементами, тогда фактически он имеет стиль `display`: `inline`, то есть сам становится строчным

- Во всех остальных случаях элемент считается блочным

**`table`** по сути превращает элемент в таблицу. Посмотрим на примере списка.

Здесь список превращается в таблицу, а каждый элемент списка - в отдельную ячейку. Для этого у элемента списка устанавливается стиль `display: table-cell`. Фактически вместо этого списка мы могли бы использовать стандартную таблицу:

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Свойство display в CSS3</title>
        <style>
            ul{
                display: table;
                margin: 0;
            }
            li{
                list-style-type: none;
                display: table-cell;
                padding: 10px;
            }
        </style>
    </head>
    <body>
        <ul>
            <li>Item 1</li>
            <li>Item 2</li>
            <li>Item 3</li>
        </ul>
    </body>
</html>
```

## Создание панели навигации

### Вертикальное меню

Распространенное решение данной проблемы для создания вертикального меню состоит в том, чтобы сделать ссылку блочным элементом. После установки свойства `display: block` мы можем определить у блока ссылки ширину, отступы и т.д.

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Панель навигации в HTML5</title>
        <style>
            ul.nav{
                margin-left: 0px;
                padding-left: 0px;
                list-style: none;
            }
            ul.nav a {
                display: block;
                width: 7em;
                padding:10px;
                background-color: #f4f4f4;
                border-top: 1px dashed #333;
                border-right: 1px dashed #333;
                border-left: 5px solid #333;
                text-decoration: none;
                color: #333;
            }
            ul.nav li:last-child a {
                border-bottom: 1px dashed #333;
            }
        </style>
    </head>
    <body>
        <ul class="nav">
            <li><a href="#">Главная</a></li>
            <li><a href="#">Контакты</a></li>
            <li><a href="#">О сайте</a></li>
        </ul>
    </body>
</html>
```

### Горизонтальное меню

Для создания горизонтального меню есть два метода. Первый заключается в применении свойства `float` и создании из ссылок плавающих элементов, которые обтекают друг друга с слева. И второй способ состоит в создании строки ссылок с помощью установки свойства display: `inline-block`.

1. **Использование `float`**

Алгоритм создания панели навигации с помощью float разделяется на два этапа. На первом этапе у элемента li, в который заключена ссылка, устанавливается float: left;. Это позволяет расположить все элементы списка в ряд при достаточной ширине, когда правый элемент списка обтекает левый элемент списка.

Второй этап заключается в установке у элемента ссылки `display: block`, что дает нам возможность устанавливать ширину, отступы, вообщем все те признаки, которые характерны для блочных элементов.

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Панель навигации в HTML5</title>
        <style>
            ul.nav{
                margin-left: 0px;
                padding-left: 0px;
                list-style: none;
            }
            .nav li { 
                float: left;
            }
            ul.nav a {
                display: block;
                width: 5em;
                padding:10px;
                margin: 0 5px;
                background-color: #f4f4f4;
                border: 1px dashed #333;
                text-decoration: none;
                color: #333;
                text-align: center;
            }
            ul.nav a:hover{
                background-color: #333;
                color: #f4f4f4;
            }
        </style>
    </head>
    <body>
        <ul class="nav">
            <li><a href="#">Главная</a></li>
            <li><a href="#">Блог</a></li>
            <li><a href="#">Контакты</a></li>
            <li><a href="#">О сайте</a></li>
        </ul>
    </body>
</html>
```

2. **`inline` и `inline-block`**

Для создания горизонтальной панели навигации нам надо сделать каждый элемент `li` строчным, то есть установить для него `display: inline`. После этого для элемента ссылки, которая располагается в элементе `li`, мы можем установить `display: inline-block`:

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Панель навигации в HTML5</title>
        <style>
            ul.nav{
                margin-left: 0px;
                padding-left: 0px;
                list-style: none;
            }
            .nav li { 
                display: inline; 
            }
            ul.nav a {
                display: inline-block;
                width: 5em;
                padding:10px;
                background-color: #f4f4f4;
                border: 1px dashed #333;
                text-decoration: none;
                color: #333;
                text-align: center;
            }
            ul.nav a:hover{
                background-color: #333;
                color: #f4f4f4;
            }
        </style>
    </head>
    <body>
        <ul class="nav">
            <li><a href="#">Главная</a></li>
            <li><a href="#">Блог</a></li>
            <li><a href="#">Контакты</a></li>
            <li><a href="#">О сайте</a></li>
        </ul>
    </body>
</html>

```

### Выравнивание плавающих элементов

Зачастую браузеры своеобразно интерпретируют размеры элемента. В частности, у всех элементов по умолчанию для свойства `box-sizing` используется значение `content-box`, то есть при определении ширины и высоты элемента браузер будет прибавлять к значению свойств `width` и `height` также и внутренние отступы `padding` и ширину границы. В итоге это может привести к выпадению плавающих элементов из тех блоков, которые для них предназначены. Поэтому часто для всех элементов рекомендуется устанавливать для свойства `box-sizing` значение `border-box`, чтобы все элементы измерялись одинаково, а их ширина представляла только значение свойства `width`. Поэтому нередко в стилях добавляется следующий стиль:

```css
* {
    box-sizing: border-box;
}
```

Ещё одна проблема - проблема отступов заключается в том, что браузер по умолчанию определяет для различных элементов встроенные стили. Поэтому может немного сбивать с толку, как и где эти стили определены, почему они применются. Нередко для решения этой проблемы разработчики просто сбрасывают некоторые наиболее значимые стили для большинства элементов:

```css
html, body, div, span, h1, h2, h3, h4, h5, h6, p, a, img, dl, dt, dd, 
ol, ul, li, form, table, caption, tr, th, td, article, aside, footer, header{
                 
    margin: 0;
    padding: 0;
    border: 0;
    font-size: 100%;
    vertical-align: baseline;
}
```

Более сложной является проблема с выпадением плавающих элементов меню из границ блока-контейнера. Здесь есть два возможных варианта Решения. Первое решение состоит в добавлении к элементу, который представляет панель навигации, следующего стиля:

```css
ul:after {
    content: " ";
    display: table;
    clear: both;
}
```

Второе решение состоит в том, чтобы сделать сам блок панели навигации плавающим:

```css
#nav{
    background-color: #f4f4f4;
    border-top: 1px solid #ccc;
    border-bottom: 1px solid #ccc;
     
    float:left;
    width: 100%;
    clear: both;
}
```

## [Создание простейшего макета](https://metanit.com/web/html5/8.8.php)

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <!-- <link href="styles.css" rel="stylesheet"> -->
        <title>Блочная верстка в HTML5</title>
      <style>
        * {
    box-sizing: border-box;
}
html, body, div, span, h1, h2, h3, h4, h5, h6, p, a, ul, li{
                 
    margin: 0;
    padding: 0;
    border: 0;
    font-size: 100%;
    vertical-align: baseline;
}
body {
    font-family: Verdana, Arial, sans-serif;    
    background-color: #f7f7f7;
}
#header{ 
    background-color: #f4f4f4;
}
#header h1 {
    font-size: 24px;
    text-transform: uppercase;
    font-weight: bold;
    padding: 30px 30px 30px 10px;
    clear: both;
}
#nav {
    background-color: #eee;
    border-top: 1px solid #ccc;
    border-bottom: 1px solid #ccc;
}
#nav li {
    float: left;
    list-style: none;   
}
#nav a {
    display: block;
    color: black;
    padding: 10px 25px;
    text-decoration: none;
    border-right: 1px solid #ccc;
}
#nav li:last-child a {
    border-right: none; 
}
#nav a:hover {
    font-weight: bold;
}
#nav:after {
    content: " ";
    display: table;
    clear: both;
}
.wrapper{
    background-color: #f7f7f7;
}
.aside h2 {
    font-size: 0.95em;
    margin-top: 15px;
}
.aside h3 {
    font-size: 0.85em;
    margin-top: 10px;
}
.aside p, .aside li {
    font-size: .75em;
    margin-top: 10px;   
}
.aside li{ 
    list-style-type: none;
}
#sidebar1 {
    float: left;
    width: 20%; 
    padding: 0 10px 0 20px;
}
#sidebar2 {
    float: right;
    width: 20%; 
    padding: 0 20px 0 10px;
}
#article{
    background-color: #fafafa;
    border-left: 1px solid #ccc;
    border-right: 1px solid #ccc;
    margin-left: 20%;
    margin-right: 20%;
    padding: 15px;
    width: 60%;
}
#article:after{
    clear:both;
    display:table;
    content:'';
}
#article h2{
    font-size: 1.3em;
    margin-bottom:15px;
}
#article p{
    line-height: 150%;
    margin-bottom: 15px;
}
#footer{ 
    border-top: 1px solid #ccc;
    font-size: .8em;    
    text-align: center;
    padding: 10px 10px 30px 10px;
}
#nav ul, #header h1, .wrapper, #footer p {
    max-width: 1200px;
    margin: 0 auto; 
}
.wrapper, #nav, #header, #footer{
    min-width: 768px;
}
      </style>
    </head>
    <body>
        <div id="header">
            <h1>MySyte.com - Сайт о Lorem Ipsum</h1>
            <div id="nav">
                <ul>
                    <li><a href="#">Главная</a></li>
                    <li><a href="#">Блог</a></li>
                    <li><a href="#">Форум</a></li>
                    <li><a href="#">Контакты</a></li>
                    <li><a href="#">О сайте</a></li>
                </ul>
            </div>
        </div>
        <div class="wrapper">
            <div id="sidebar1" class="aside">
                <h2>The standard Lorem Ipsum passage</h2>
                <p>"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt 
                ut labore et dolore magna aliqua..."</p>
                </div>
            <div id="sidebar2" class="aside">
                <h2>1914 translation by H. Rackham</h2>
                <p>It is a long established fact that a reader will be distracted by the readable 
                content of a page when looking at its layout.</p>
                <h3>Options</h3>
                <ul>
                    <li>Item1</li>
                    <li>Item2</li>
                    <li>Item3</li>
                </ul>
            </div>
            <div id="article">
                <h2>What is Lorem Ipsum?</h2>
                <p>Lorem Ipsum is simply dummy text of the printing and typesetting industry...</p>
                <p>Contrary to popular belief, Lorem Ipsum is not simply random text. It has roots in a piece of 
                classical Latin literature from 45 BC, making it over 2000 years old. Richard McClintock, 
                a Latin professor at Hampden-Sydney College in Virginia...</p>
            </div>
        </div>
        <div id="footer">
            <p>Contacts: admin@mysyte.com</p>
            <p>Copyright © MySyte.com, 2016</p>
        </div>
    </body>
</html>
```

## Позиционирование

Основным свойством, которые управляют позиционированием в CSS, является свойство `position`. Это свойство может принимать одно из следующих значений:

|position:|результат|
|-|-|
|static|стандартное позиционирование элемента, значение по умолчанию|
|absolute|элемент позиционируется относительно границ элемента-контейнера, если у того свойство position не равно `static`|
|relative|элемент позиционируется относительно его позиции по умолчанию. Как правило, основная цель относительного позиционирования заключается не в том, чтобы переместить элемент, а в том, чтобы установить новую точку привязки для абсолютного позиционированния вложенных в него элементов|
|fixed|элемент позиционируется относительно окна бразуера, это позволяет создать фиксированные элементы, которые не меняют положения при прокрутке|

> Не следует одновременно применять к элементу свойство `float` и любой тип позиционирования, кроме `static` (то есть тип по умолчанию).

### Абсолютное позиционирование

Область просмотра браузера имеет верхний, нижний, правый и левый края

|свойство|назначение|
|-|-|
|left|отступ от края слева|
|right|отступ от края справа|
|top|отступ от края контейнера сверху|
|bottom |отступ снизу|

Значения этих свойств указываются в пикселях, em или процентах. Необязательно задавать значения для всех четырех сторон. Как правило, устанавливают только два значения - отступ от верхнего края `top` и отступ от левого края `left`.

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Блочная верстка в HTML5</title>
        <style>
            .header {
                position: absolute;
                left: 100px;
                top: 50px;
                width: 430px;
                height: 100px;
                background-color: rgba(128, 0, 0, 0.5);
            }
        </style>
    </head>
    <body>
        <div class="header"></div>
        <p>HELLO WORLD</p>
    </body>
</html>
```
> При этом не столь важно, что после этого элемента `div` идут какие-то другие элементы. Данный блок `div` в любом случае будет позиционироваться относительно границ области просмотра браузера.

> Если элемент с абсоютным позиционированием располагается в другом контейнере, у которого в свою очередь значение свойства `position` не равно `static`, то элемент позиционируется относительно границ контейнера:

### Относительное позиционирование

Относительное позиционирование также задается с помощью значения `relative`. Для указания конкретной позиции, на которую сдвигается элемент, применяются те же свойства `top`, `left`, `right`, `bottom`:

### Свойство `z-index`

По умолчанию при совпадении у двух элементов границ, поверх другого отображается тот элемент, который определен в разметке html последним. Однако свойство `z-index` позволяет изменить порядок следования элементов при их наложении. В качестве значения свойство принимает число. Элементы с большим значением этого свойства будут отображаться поверх элементов с меньшим значением `z-index`.

### Фиксированное позиционирование

Фиксированное позиционирование является распространенным способом удержать в области просмотра браузера некоторые элементы.

Для фиксированного позиционирования у элементов нужно установить значение `fixed` для свойства `position`. После этого с помощью стандартных свойств `left`, `right`, `top` и `bottom` можно определить конкретную позицию фиксированного элемента.

Чтобы растянуть фиксированный блок от левой до правой границы страницы, устанавливаются три свойства:

```css
top: 0;
left: 0;
right: 0;
```

Для нижележащего блока с основным содержанием фиксированный элемент фактически не существует разметке, так как блок с фиксированным, как и с абсолютным  позиционированием не учавствуют в стандартном потоке html. Поэтому по умолчанию оба блока будут накладываться друг на друга и размещатьс в одной точке. И нам надо должным образом разместить блок содержимого относительно фиксированного блока, например, установив нужный отступ:

```css
margin-top: 50px;
```
Фактически отступ идет от границ области просмотра браузера, поэтому высота отступа должна быть больше высоты фиксированного элемента.

## Трансформации

Для создания трансформаций в CSS3 применяется свойство `transform`:

|transform:|результат|
|-|-|
|rotate(угол_поворота deg)|поворот на угол в градусах|
|scale(величина_масштабирования)|масштабирование элемента|
|scale(по_горизонтали по_вертикали)|масштабирование элемента по осям|
|scaleX(величина_масштабирования)|по горизонтали|
|scaleY(величина_масштабирования)|по вертикали|
|translate(offset_X, offset_Y)|перемещение элемента|
|translateX(offset_X)|перемещение элемента по горизонтали|
|translateY(offset_Y)|перемещение элемента по вертикали|
|skew(X, Y)|наклон элемента в градусах для каждой оси|
|skewX(X)|наклон элемента по оси X|
|skewY(Y)|наклон элемента по оси Y|


### Комбинирование преобразований

```css
transform: translate(50px, 100px) skew(30deg, 10deg) scale(1.5) rotate(90deg);
```

### Исходная точка трансформации

По умолчанию при применении трансформаций браузер в качестве точки начала преобразования использует центр элемента. Но с помощью свойства `transform-origin` можно изменить исходную точку. Это свойство в качестве значения принимает значения в пикселях, em и процентах. Также для установки точки можно использовать ключевые слова:

|transform-origin:|результат|
|-|-|
|left top|левый верхний угол элемента|
|left bottom|левый нижний угол элемента|
|right top|правый верхний угол элемента|
|right bottom|правый нижний угол элемента|

## Переходы

Переход `transition` представляет анимацию от одного стиля к другому в течение определенного периода времени.

Для создания перехода необходимы прежде всего два набора свойств CSS: начальный стиль, который будет иметь элемент в начале перехода, и конечный стиль - результат перехода. Так, рассмотрим простейший переход:

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Переход в CSS3</title>
        <style>
            div{
                width: 100px;
                height: 100px;
                margin: 40px 30px;
                border: 1px solid #333;
                 
                background-color: #ccc;
                transition-property: background-color;
                transition-duration: 2s;
            }
            div:hover{
                background-color: red;
            }
        </style>
    </head>
    <body>
        <div></div>
    </body>
</html>
```

Здесь анимируется свойство `background-color` элемента `div`. При наведении указателя мыши на элемент он будет менять цвет с серого на красный. А при увеении указателя мыши с пространства элемента будет возвращаться исходный цвет.

Чтобы указать свойство как анимируемое, его название передается свойству `transition-property`

```css
transition-property: background-color;
```

Полный список свойств CSS, которые поддаются анимации, можно найти по [адресу](http://www.w3.org/TR/css3-transitions/#animatable-properties)

Далее идет установка времени перехода в секундах с помощью свойства transition-duration:

```css
transition-duration: 2s;
```

И в конце нам надо определить инициатор действия и финальное значение анимируемого свойства `background-color`. Инициатор представляет действие, которое приводит к изменению одного стиля на другой. В CSS для запуска перехода можно применять псевдоклассы. Например, здесь для создания перехода используется стиль для псевдокласса `:hover`. То есть при наведении указателя мыши на элемент `div`, будет срабатывать переход.

Кроме псевдокласса `:hover` можно использовать и другие псевдоклассы, например, `:active` (ссылка в нажатом состоянии) или `:focus` (получение элементом фокуса).

Также для запуска перехода можно использовать код JavaScript

При необходимости можно анимировать сразу несколько свойств. Для каждого из свойств можно задать своё время или для всех одно.

```css
transition-property: background-color, width, height, border-color;
transition-duration: 2s, 3s, 1s, 2s;
```

Кроме перечисления через запятую всех анимируемых свойств мы можем просто указать ключевое слово all:

```css
transition-property: all;
transition-duration: 2s;
```

### Функции анимации

Свойства `transition-timing-function` позволяет контролировать скорость хода и выполнение анимации. То есть данное свойство отвечает за то, как и в какие моменты времени анимация будет ускоряться или замедляться.

|transition-timing-function:|результат|
|-|-|
|linear|линейная функция плавности, изменение свойства происходит равномерно по времени|
|ease|функция плавности, при которой анимация ускоряется к середине и замедляется к концу, предоставляя более естественное изменение|
|ease-in|функция плавности, при которой происходит только ускорение в начале|
|ease-out|функция плавности, при которой происходит только ускорение в конце анимации|
|ease-in-out|функция плавности, при которой анимация ускоряется к середине и замедляется к концу, предоставляя более естественное изменение|
|cubic-bezier|для анимации применяется кубическая функция Безье|

```css
div{
    width: 100px;
    height: 100px;
    margin: 40px 30px;
    border: 1px solid #333;
        
    background-color: #ccc;
    transition-property: background-color, width;
    transition-duration: 2s, 10s;
    transition-timing-function: ease-in-out;
}
div:hover{
    background-color: red;
    width: 200px;
}
```
Для использования кубической Безье в функцию cubic-bezier необходимо передать ряд значений:

```css
transition-timing-function: cubic-bezier(.5, .6, .24, .18);
```

> Кубическая функция Безье (cubic-bezier) в CSS — это функция cubic-bezier(x2, y2, x3, y3), которая используется для создания пользовательских кривых ускорения и замедления анимации. Она управляет темпом, задавая две контрольные точки (\(x_{2}\), \(y_{2}\)) и (\(x_{3}\), \(y_{3}\)), при этом начальная точка (\(0,0\)) и конечная точка (\(1,1\)) фиксированы. По оси X откладывается время (от 0 до 1), а по оси Y — степень завершенности анимации (от 0 до 1). 

### Задержка перехода

Свойство `transition-delay` позволяет определить задержку перед выполнением перехода:

```css
transition-delay: 500ms;
```

Временной период также указывается в секундах (s) или миллисекундах (ms).

### Свойство transition

Свойство `transition` представляет сокращенную запись выше рассмотренных свойств. Например, следующее описание свойств:

```css
transition-property: background-color;
transition-duration: 3s;
transition-timing-function: ease-in-out;
transition-delay: 500ms;
```

Будет аналогично следующей записи:

```css
transition: background-color 3s ease-in-out 500ms;
```

## Анимация

Анимация опирается на последовательню смену ключевых кадров (`keyframes`). Каждый ключевой кадр определяет один набор значений для анимируемых свойств. И последовательная смена таких ключевых кадров фактически будет представлять анимацию.

В целом объявление ключевого кадра в CSS3 имеет следующую форму:

```css
@keyframes название_анимации {
    from {
        /* начальные значения свойств CSS */
    }
    to {
        /* конечные значения свойств CSS */
    }
}
```

В случае использования множества промежуточных кадров, применяется следующая форма:

```css
@keyframes backgroundColorAnimation {
    from {
        background-color: red;
    }
    25%{
        background-color: yellow;
    }
    50%{
        background-color: green;
    }
    75%{
        background-color: blue;
    }
    to {
        background-color: violet;
    }
}
```
> Блоки `from` и `to` могут быть опущены.

Для привязки к элементу анимации, нужно в его стиле описать свойства:

```css
animation-name: название_анимации;
animation-duration: длительность_анимации;
```
При подобном определении анимация будет запускаться сразу после загрузки страницы. Однако можно также запускать анимацию по действию пользователя, например с помощью определения стиля для псевдокласса `:hover` и описания в нём вышеуказанных свойств.

Можно применять через запятую несколько анимаций, указав, через запятую для них `animation-duration`

### Завершение анимации

В общем случае после завершения временного интервала, указанного у свойства `animation-duration`, завершается и выполнение анимации. Однако с помощью дополнительных свойств мы можем переопределить это поведение.

- **`animation-iteration-count`** определяет, сколько раз будет повторяться анимация.:

```css
animation-iteration-count: 3;
```
Если необходимо, чтобы анимация запускалась бесконечное количество раз:

```css
animation-iteration-count: infinite;
```

- **`animation-direction: alternate`** определяет противоположное направление анимации при повторе.

- **`animation-fill-mode: forwards`** позволяет в качестве окончательного значения анимируемого свойства установить именно то, которое было в последнем кадре, тогда как по умолчанию, при окончании анимации браузер устанавливает для анимированного элемента стиль, который был бы до применения анимации.

- **`animation-delay`** определяет время задержки анимации

- **`animation-timing-function`** устанавливает функцию плавности

    |animation-timing-function:|результат|
    |-|-|
    |linear|линейная функция плавности, изменение свойства происходит равномерно по времени|
    |ease|функция плавности, при которой анимация ускоряется к середине и замедляется к концу, предоставляя более естественное изменение|
    |ease-in|функция плавности, при которой происходит только ускорение в начале|
    |ease-out|функция плавности, при которой происходит только ускорение в конце анимации|
    |ease-in-out|функция плавности, при которой анимация ускоряется к середине и замедляется к концу, предоставляя более естественное изменение|
    |cubic-bezier|для анимации применяется кубическая функция Безье|

- **`animation`** является сокращенным способом определения выше рассмотренных свойств:

    ```css
    animation: animation-name animation-duration animation-timing-function animation-iteration-count animation-direction animation-delay animation-fill-mode
    ```

## Создание баннера с анимацией

```html
<!DOCTYPE html>
<html>
<head>
    <title>HTML-баннер</title>
    <meta charset="utf-8" />
    <style type="text/css">
    @keyframes text1
    {
        10%{opacity: 1;}
        40%{opacity: 0;}
    }  
    @keyframes text2
    {
        30%{opacity: 0;}
        60%{opacity:1;}
    }
    @keyframes banner
    {
        10%{background-color: #008978;}
        40%{background-color: #34495e;}
        80%{background-color: green;}
    }
    .banner
    {
        width: 600px;
        height: 120px;
        background-color: #777;
        margin: 0 auto;
        position: relative;
    }
    .text1,.text2
    {
        position: absolute;
        width: 100%;
        height: 100%;
        line-height: 120px;
        text-align: center;
        font-size: 40px;
        color: #fff;
        opacity: 0;
    }
 
    .text1
    {
        animation : text1 6s infinite;
    }
 
    .text2
    {
        animation : text2 6s infinite;
    }
 
    .animated
    {
        opacity: 0.8;
        position: absolute;
        width: 100%;
        height: 100%;  
        background-color: #34495e;
        animation: banner 6s infinite;
    }
    </style>
</head>
<body>
    <div class="banner">
        <div class="animated">
            <div class="text1">Только в этом месяце</div>
            <div class="text2">Скидки по 20%</div>
        </div>
    </div>
</body>
</html>
```
> Здесь одновременно срабатывают три анимации. Анимация "banner" изменяет цвет фона баннера, а анимации text1 и text2 отображают и скрывают текст с помощью настроек прозрачности. Когда первый текст виден, второй не виден и наоборот. Тем самым мы получаем анимацию текста в баннере.

## Адаптивный дизайн

### Метатег `viewport`

Вся видимая область на экране браузера описывается понятием **Viewport**. По сути `viewport` представляет область, в которую веб-браузер пытается "впихнуть" веб-страницу. 

Чтобы избежать неприятных ситуаций при просмотре страницы на устройствах с различными размерами экранов и использующих различные браузеры, следует использовать метатег `viewport`, имеющий следущее определение:

```html
<meta name="viewport" content="параметры_метатега">
```

В атрибуте content мета-тега мы можем определить следующие параметры:

|Параметр|Значения|Описание|
|-|-|-|
|width|Принимает целочисленное значение в пикселях или значение `device-width`|Устанавливает ширину области `viewport`|
|height|Принимает целочисленное значение в пикселях или значение `device-height`|Устанавливает высоту области viewport|
|initial-scale|Число с плавающей точкой от 0.1 и выше|Задает коэффициент масштабирования начального размера viewport. Значение 1.0 задает отсутствие масштабирования|
|user-scalable|no/yes|Указывает, может ли пользователь с помощью жестов масштабировать страницу|
|minimum-scale|Число с плавающей точкой от 0.1 и выше|Задает минимальный масштаб размера viewport. Значение 1.0 задает отсутствие масштабирования|
|maximum-scale|Число с плавающей точкой от 0.1 и выше|Задает максимальный масштаб размера viewport. Значение 1.0 задает отсутствие масштабирования|

Таким образом, чтобы веб-браузер в качестве начальной ширины экрана использовал ширину экрана устройства, достаточно в теле заголовка использовать тег:

```html
<meta name="viewport" content="width=device-width">
```

Мы также можем использовать другие параметры, например, запретить пользователю масштабировать размеры страницы:

```html
<meta name="viewport" content="width=device-width, maximum-scale=1.0, minimum-scale=1.0">
```

### Media Query в CSS3

Чтобы применить стиль только к мобильным устройствам мы можем написать так:

```html
<html>
 <head>
  <title>Адаптивная веб-страница</title>
  <meta name="viewport" content="width=device-width">
  <link rel="stylesheet" type="text/css" href="desctop.css" />
  <link rel="stylesheet" type="text/css" media="(max-device-width:480px)" href="mobile.css" />
 </head>
 <body>
 ```

 С помощью директивый **`@import`** можно определить один css-файл и импортировать в него стили для определенных устройств:

```css
@import url(desctop.css);
@import url(tablet.css) (min-device-width:481px) and (max-device-width:768);
@import url(mobile.css) (max-device-width:480px);
```

Также можно не разделять стили по файлам, а использовать правила CSS3 Media Query в одном файле css:

```css
body {
    background-color: red;
}
/*Далее остальные стили*/
@media (max-device-width:480px){
    body {
        background-color: blue;
    }
    /*Далее остальные стили*/
}
```

Применяемые функции в CSS3 Media Query:
|функция|параметр|
|-|-|
|aspect-ratio|отношение ширины к высоте области отображения (браузера)|
|device-aspect-ratio|отношение ширины к высоте экрана устройства|
|max-width|максимальная ширина области отображения (браузера)|
|min-width|минимальная ширина|
|max-height|максимальная высота|
|min-height|минимальная высота|
|orientation|ориентация (portrait, landscape)|

Как правило, при определении стилей предпочтение отдается стилям для самых малых экранов - так называемый подход **Mobile First**, хотя это необязательно.

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width">
        <title>Адаптивная веб-страница</title>
         
        <style>
        body {
            background-color: red;
        }
        /* для планшетов и фаблетов */
        @media (min-width: 481px) and (max-width:768px) {
            body {
                background-color: green;
            }
        }
        /* для декстопов */
        @media (min-width:769px) {
            body {
                background-color: blue;
            }
        }
</style>
    </head>
    <body>
        <h2>Адаптивная веб-страница</h2>
    </body>
</html>
```

## Flexbox

> **Flexbox** - это общее название для модуля **Flexible Box Layout**, который имеется в CSS3. Данный модуль определяет особый режим компоновки/верстки пользовательского интерфейса, который называется **flex layout**. 

Основными составляющими компоновки `flexbox` являются flex-контейнер (`flex container`) и flex-элементы (`flex items`). Flex container представляет некоторый элемент, внутри которого размещены flex-элементы.

- **`main axis`** центральная ось. Это условная ось во flex-контейнере, вдоль которой позиционируются flex-элементы. Если расположение в виде строки, то центральная ось направлена горизонтально слева направо. Если расположение в виде столбца, то центральная ось направлена вертикально сверху вниз.

- **`main start`** начало центральной оси 

- **`main end`** конец центральной оси

- **`main size`** расстояние между концом и началом

- **`cross axis`** поперечная ось. Она перпендикулярна основной. При расположении элементов в виде строки `cross axis` направлена сверху вниз, а при расположении в виде столбца она направлена слева направо. 

- **`cross start`** начало поперечной оси 

- **`cross end`** конец поперечной оси

- **`cross size`** расстояние между концом и началом

То есть, если элементы располагаются в строку, то `main size` будет представлять ширину контейнера или элементов, а `cross size` - их высоту. Если же элементы располагаются в столбик, то, наоборот, `main size` представляет высоту контейнера и элементов, а `cross size` - их ширину.

### Создание flex-контейнера

Для создания flex-контейнера необходимо присвоить его стилевому свойству `display` одно из двух значений: `flex` или `inline-flex`.

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Flexbox в CSS3</title>
        <style>
            .flex-container {
                display: flex;
                border:2px solid #ccc;
            }
            .inline-flex-container {
                display: inline-flex;
                border:2px solid #ccc;
                margin-top:10px;
            }
            .flex-item {
                text-align:center;
                font-size: 1.1em;
                padding: 1.5em;
                color: white;
            }
            .color1 {background-color: #675BA7;}
            .color2 {background-color: #9BC850;}
            .color3 {background-color: #A62E5C;}
        </style>
    </head>
    <body>
        <div class="flex-container">
            <div class="flex-item color1">Flex Item 1</div>
            <div class="flex-item color2">Flex Item 2</div>
            <div class="flex-item color3">Flex Item 3</div>
        </div>
         
        <div class="inline-flex-container">
            <div class="flex-item color1">Flex Item 1</div>
            <div class="flex-item color2">Flex Item 2</div>
            <div class="flex-item color3">Flex Item 3</div>
        </div>
    </body>
</html>
```

### Направление **`flex-direction`**
Flex-элементы во flex-контейнере могут иметь определенное направление, а именно они могут располагаться в виде строк или в виде столбцов. 


|flex-direction:|результат|
|-|-|
|row|значение по умолчанию, при котором элементы располагаются в виде строки слева  направо|
|row-reverse|элементы также располагаются в виде стоки только в обратном порядке справа налево|
|column|элементы располагаются в столбик сверху вниз|
|column-reverse|элементы располагаются в столбик в обратном порядке снизу вверх

### Свойство **`flex-wrap`**

Определяет, будет ли flex-контейнер несколько рядов элементов (строк или столбцов) в случае если его размеры недостаточны, чтобы вместить в один ряд все элементы. 

|||
|-|-|
|nowrap|значение по умолчанию, которое определяет flex-контейнер, где все элементы раполагаются в одну строку (при расположении в виде строк) или один столбец (при расположении в столбик)|
|wrap|если элементы не помещаются во flex-контейнер, то создает дополнительные ряды в контейнере для размещения элементов. При расположении в виде строки содаются дополнительные строки, а при расположении в виде столбца добавляются дополнительные столбцы|
|wrap-reverse|то же самое, что и значение wrap, только элементы располагаются в обратном порядке|

### Порядок элементов. **`flex-flow`**

позволяет установить значения сразу для обоих свойств `flex-direction` и `flex-wrap`. Оно имеет следующий формальный синтаксис:

```css
flex-flow: [flex-direction] [flex-wrap]
/* второе свойство - flex-wrap можно опустить, тогда для него будет использоваться значение по умолчанию - nowrap. */
```

### Свойство **`order`**

Позволяет установить группу для flex-элемента, позволяя тем самым переопределить его позицию внутри flex-контейнера. В качестве значения свойство принимает целочисленный порядок группы. К одной группе может принадлежать несколько элементов.

Элементы в группе с меньшим порядковым номером располагаются перед элементами группы с большим номером.

По умолчанию если у элементов явным образом не указано свойство order, то оно имеет значение 0. 

### Выравнивание элементов. **`justify-content`**

Иногда мы можем сталкиваться с тем, что пространство flex-контейнеров по размеру отличается от пространства, необходимого для flex-элементов. Например:

- flex-элементы не используют все пространство flex-контейнера

- flex-элементам требуется большее пространство, чем доступно во flex-контейнере. В этом случае элементы выходят за пределы контейнера.

Для управления этими ситуациями мы можем применять свойство `justify-content`. Оно выравнивает элементы вдоль основной оси - main axis (при расположении в виде строки по горизонтали, при расположении в виде столбца - по вертикали) и принимает следующие значения:

|justify-content:|результат|
|-|-|
|flex-start|значение по умолчанию, при котором первый элемент выравнивается по левому краю контейнера(при расположении в виде строки) или по верху (при расположении в виде столбца), за ним располагается второй элемент и так далее.|
|flex-end|последний элемент выравнивается по правому краю (при расположении в виде строки) или по низу (при расположении в виде столбца) контейнера, за ним выравнивается предпоследний элемент и так далее|
|center|элементы выравниваются по центру|
|space-between|если в стоке только один элемент или элементы выходят за границы flex-контейнера, то данное значение аналогично flex-start. В остальных случаях первый элемент выравнивается по левому краю (при расположении в виде строки) или по верху (при расположении в виде столбца), а последний элемент - по правому краю контейнера (при расположении в виде строки) или по низу (при расположении в виде столбца). Все оставшееся пространство между ними равным образом распределяется между остальными элементами
|space-around|если в строке только один элемент или элементы выходят за пределы контейнера, то его действие аналогично значению center. В ином случае элементы равным образом распределяют пространство между левым и правым краем контейнера, а расстояние между первым и последним элементом и границами контейнера составляет половину расстояния между элементами.|

### Выравнивание элементов по поперечной оси. `align-items` и `align-self`

- **Свойство `align-items`**

Свойство align-items также выравнивает элементы, но уже по поперечной оси (cross axis) (при расположении в виде строки по вертикали, при расположении в виде столбца - по горизонтали).

|align-items:|результат|
|-|-|
|stretch|значение по умолчанию, при котором flex-элементы растягиваются по всей высоте (при расположении в строку) или по всей ширине (при расположении в столбик) flex-контейнера|
|flex-start|элементы выравниваются по верхнему краю (при расположении в строку) или по левому краю (при расположении в столбик) flex-контейнера|
|flex-end|элементы выравниваются по нижнему краю (при расположении в строку) или по правому краю (при расположении в столбик) flex-контейнера|
|center|элементы выравниваются по центру flex-контейнера|
|baseline|элементы выравниваются в соответствии со своей базовой линией|

- **Свойство `align-self`**

Свойство `align-self` позволяет переопределить значение свойства `align-items` для одного элемента. Оно может принимать все те же значения плюс значение `auto`:

- **`auto`** значение по умолчанию, при котором элемент получает значение от свойства `align-items`, которое определено в flex-контейнере. Если в контейнере такой стиль не определен, то применяется значение `stretch`.

Здесь для flex-контейнера задано растяжение по высоте с помощью значения `align-items: stretch;`. Однако каждый из элементов переопределяет это поведение:

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Flexbox в CSS3</title>
        <style>
            .flex-container {
                display: flex;
                border:1px #ccc solid;
                justify-content: space-between;
                align-items: stretch;
                height:12em;
            }
            .flex-item {
                text-align:center;
                font-size: 1em;
                padding: 1.2em;
                color: white;
            }
            .item1 {background-color: #675BA7; align-self: center; }
            .item2 {background-color: #9BC850; align-self: flex-start;}
            .item3 {background-color: #A62E5C; align-self: flex-end;}
            .item4 {background-color: #2A9FBC; align-self: center;}
        </style>
    </head>
    <body>
        <h3>Align-self</h3>
        <div class="flex-container">
            <div class="flex-item item1">Flex Item 1</div>
            <div class="flex-item item2">Flex Item 2</div>
            <div class="flex-item item3">Flex Item 3</div>
            <div class="flex-item item4">Flex Item 4</div>
        </div>
</html>
```

### Выравнивание строк и столбцов. `align-content`

Свойство `align-content` управляет выравниванием рядов (строк и столбцов) во flex-контейнере и поэтому применяется, если свойство `flex-wrap` имеет значение `wrap` или `wrap-reverse`. 

> Стоит учитывать, что это свойство имеет смысл, если в контейнере две и больше строки (столбца).

|align-content:|результат|
|-|-|
|stretch|значение по умолчанию, при котором строки (столбцы) растягиваются, занимая все свободное место|
|flex-start|строки (столбцы) выравниваются по началу контейнера (для строк - это верхний край, для столбцов - это левый край контейнера)|
|flex-end|строки (столбцы) выравниваются по концу контейнера (строки - по нижнему краю, столбцы - по правому краю)|
|center|строки (столбцы) позиционируются по центру контейнера|
|space-between|строки (столбцы) равномерно распределяются по контейнеру, а между ними образуются одинаковые отступы. Если же имеющегося в контейнере места недостаточно, то действует аналогично значению flex-start|
|space-around|строки (столбцы) равным образом распределяют пространство контейнера, а растояние между первой и последней строкой (столбцом) и границами контейнера составляет половину расстояния между соседними строками (столбцами).|

### Управление элементами. `flex-basis`, `flex-shrink` и `flex-grow`

|свойство|назначение|
|-|-|
|flex-basis|определяет начальный размер flex-элемента|
|flex-shrink|определяет, как flex-элемент будет уменьшаться относительно других flex-элементов во flex-контейнере|
|flex-grow|определяет, как flex-элемент будет увеличиваться относительно других flex-элементов во flex-контейнере|

- **`flex-basis`**
> определяет начальный размер flex-элемента до того, как он начнет изменять размер, подстраиваясь под размеры flex-контейнера.

|flex-basis:|результат|
|-|-|
|auto|начальный размер flex-элемента устанавливается автоматически|
|content|размер flex-элемента определяется по его содержимому, в то же время это значение поддерживается не всеми современными браузерами, поэтому его пока стоит избегать|
|числовое значение|мы можем установить конкретное числовое значение для размеров элемента|

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Flexbox в CSS3</title>
        <style>
            .flex-container {
                display: flex;
                border:1px #ccc solid;
            }
            .flex-item {
                text-align:center;
                font-size: 1em;
                padding: 1.2em;
                color: white;
            }
            .item1 {background-color: #675BA7; flex-basis: auto; width:150px;}
            .item2 {background-color: #9BC850; flex-basis: auto; width:auto;}
            .item3 {background-color: #A62E5C; flex-basis: 200px;width:150px;}
        </style>
    </head>
    <body>
        <div class="flex-container">
            <div class="flex-item item1">Flex Item 1</div>
            <div class="flex-item item2">Flex Item 2</div>
            <div class="flex-item item3">Flex Item 3</div>
        </div>
</html>
```

У первого элемента у свойства `flex-basis` установлено значение `auto`. Поэтому первый элемент в качестве реального значения для ширины будет использовать значение свойства `width`.

У второго элемента у свойства `flex-basis` установлено значение `auto`, однако и свойство `width` имеет значение `auto`. Поэтому реальная ширина элемента будет устанавливаться по его содержимому.

У третьего элемента свойство `flex-basis` имеет конкретное значение, которое и используется. А свойство `width` в этом случае уже не играет никакой роли.

- **`flex-shrink`**

Если flex-контейнер имеет недостаточно места для размещения элемента, то дальнейшее поведение этого элемента мы можем определить с помощью свойства `flex-shrink`. Оно указывает, как элемент будет усекаться относительно других элементов.

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Flexbox в CSS3</title>
        <style>
            .flex-container {
                display: flex;
                border:1px #ccc solid;
                width:400px;
            }
            .flex-item {
                text-align:center;
                font-size: 1em;
                padding: 1.2em;
                color: white;
            }
            .item1 {background-color: #675BA7; flex-basis: 200px; flex-shrink:1;}
            .item2 {background-color: #9BC850; flex-basis: 200px; flex-shrink:2;}
            .item3 {background-color: #A62E5C; flex-basis: 200px; flex-shrink:3;}
        </style>
    </head>
    <body>
        <div class="flex-container">
            <div class="flex-item item1">Flex Item 1</div>
            <div class="flex-item item2">Flex Item 2</div>
            <div class="flex-item item3">Flex Item 3</div>
        </div>
</html>
```
В данном случае начальная ширина каждого элемента равна 200px, то есть совокупная ширина составляет 600px. Однако ширина flex-контейнера составляет всего 400px. То есть размер контейнера недостаточен для вмещения в него элементов, поэтому в действие вступает свойство `flex-shrink`, которое определено у элементов.

Для усечения элементов браузер вычисляет коэффициент усечения (`shrinkage factor`). Он вычисляется путем перемножения значения свойства `flex-basis` на `flex-shrink`. Таким образом, для трех элементов мы получим следующие вычисления:

```
// первый элемент
200px * 1 = 200
// второй элемент
200px * 2 = 400
// третий элемент
200px * 3 = 600
```

В результате первый элемент при усечении будет в три раза больше, чем третий и в два раза больше, чем второй.

- **`flex-grow`**

управляет расширением элементов, если во flex-контейнере есть дополнительное место. Данное свойство во многом похоже на свойство `flex-shrink` за тем исключением, что работает в сторону увеличения элементов.

В качестве значения свойство `flex-grow` принимает положительное число, которое указывает, во сколько раз элемент будет увеличиваться относительно других элементов при увеличении размеров flex-контейнера. По умолчанию свойство `flex-grow` равно 0.

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Flexbox в CSS3</title>
        <style>
            .flex-container {
                display: flex;
                border:1px #ccc solid;
            }
            .flex-item {
                text-align:center;
                font-size: 1em;
                padding: 1.3em;
                color: white;
            }
            .item1 {background-color: #675BA7; flex-grow:0;}
            .item2 {background-color: #9BC850; flex-grow:1;}
            .item3 {background-color: #A62E5C; flex-grow:2;}
        </style>
    </head>
    <body>
        <div class="flex-container">
            <div class="flex-item item1">Flex Item 1</div>
            <div class="flex-item item2">Flex Item 2</div>
            <div class="flex-item item3">Flex Item 3</div>
        </div>
</html>

```

Итак, для каждого элемента есть базовые начальные размеры. Здесь явным образом размеры для элементов не указаны, поэтому размер каждого элемента в данном случае будет складываться из размеров внутреннего содержимого, к которым добавляются внутренние отступы.

Пространство, на которое растягивается контейнер, считается дополнительным пространством.

Так как у первого элемента свойство `flex-grow` равно 0, то первый элемент будет иметь константные постоянные размеры. У второго элемента `flex-grow` равно 1, а третьего - 2. Таким образом, в сумме они дадут 0 + 1 + 2 = 3. Поэтому второй элемент будет увеличиваться на 1/3 дополнительного пространства, на которое растягивается контейнер, а третий элемент будет получать 2/3 дополнительного пространства.

### Свойство `flex`

является объединением свойств `flex-basis`, `flex-shrink` и `flex-grow` и имеет следующий формальный синтаксис:

```css
flex: [flex-grow] [flex-shrink] [flex-basis]
```
По умолчанию свойство `flex` имеет значение `0 1 auto`.

Кроме конкретных значений для каждого из подсвойств мы можем задать для свойства flex одно из трех общих значений:

|flex:|результат|
|-|-|
|none|эквивалентно значению 0 0 auto, при котором flex-элемент не растягивается и не усекается при увеличении и уменьшении контейнера|
|auto|эквивалентно значению 1 1 auto|
|initial|эквивалентно значению 0 1 auto|

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Flexbox в CSS3</title>
        <style>
            .flex-container {
                display: flex;
                border:1px #ccc solid;
                width: 600px;
            }
            .flex-item {
                text-align:center;
                font-size: 16px;
                padding: 10px 0;
                color: white;
            }
            .item1 {background-color: #675BA7; width: 150px; flex: 0 0 auto }
            .item2 {background-color: #9BC850; width: 150px; flex: 1 0 auto;}
            .item3 {background-color: #A62E5C; width: 150px; flex: 0 1 auto;}
            .item4 {background-color: #2A9FBC; width: 150px; flex: 1 1 auto;}
        </style>
    </head>
    <body>
        <div class="flex-container">
            <div class="flex-item item1">Flex Item 1</div>
            <div class="flex-item item2">Flex Item 2</div>
            <div class="flex-item item3">Flex Item 3</div>
            <div class="flex-item item4">Flex Item 4</div>
        </div>
</html>
```

Здесь каждый элемент имеет начальную ширину в 150 пикселей, так как у всех элементов свойство `flex-basis` имеет значение 0, что в целом для всех элементов будет составлять 600 пикселей.

При сжатии контейнера будут уменьшаться 3-й и 4-й элементы, так как у них свойство flex-shrink больше нуля. И так как у обоих элементов это свойство равно 1, то оба элемента будут уменьшаться в равных долях.

При растяжении контейнера будут увеличиваться 2-й и 4-й элементы, так как у этих элементов свойство flex-grow больше нуля. И также, так как это свойство равно 1, то эти элементы будут увеличиваться в равных долях.

## Макет страницы на Flexbox

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width" />
        <title>Flexbox в CSS3</title>
        <style>
            *{
                box-sizing: border-box;
            }
            html, body {
                padding: 0;
                margin: 0;
                font-family: verdana, arial, sans-serif;
            }
 
            body {
                color: #fff;
                font-size: 1.1em;
                padding: 1em;
                display: flex;
                flex-direction: column;
            }
 
            main {
                display: flex;
                flex-direction: column;
            }
 
            article {
                background-color: #546e7a;
                flex: 2 2 12em;
                padding: 1em;
            }
 
            nav, aside {
                flex: 1;
                background-color: #455a64;
            }
 
            nav {
                order: -1;
            }
             
            header, footer {
                flex: 0 0 5em;
                background-color: #37474f;
            }
             
            @media screen and (min-width: 600px) {
                 
                body{
                    min-height: 100vh;
                }
                main {
                    flex-direction: row;
                    min-height: 100%;
                    flex: 1 1 auto;
                }
            }
        </style>
    </head>
    <body>
        <header>
            <p>Header</p>
        </header>
        <main>
            <article>
                <h1>Что такое Lorem Ipsum?</h1>
                <p>Lorem Ipsum - это текст-"рыба", часто используемый в печати и вэб-дизайне. Lorem Ipsum является стандартной 
                "рыбой" для текстов на латинице с начала XVI века. В то время некий безымянный печатник создал большую коллекцию 
                размеров и форм шрифтов, используя Lorem Ipsum для распечатки образцов. Lorem Ipsum не только успешно пережил без 
                заметных изменений пять веков, но и перешагнул в электронный дизайн. Его популяризации в новое время</p>
            </article>
            <nav>
                <p>Navigation</p>
            </nav>
            <aside>
                <p>Sidebar</p>
            </aside>
        </main>
        <footer>
            <p>Footer</p>
        </footer>
    </body>
</html>
```

Итак, flex-контейнером верхнего уровня здесь является элемент `body`. Его flex-элементами являются `header`, `main` и `footer`. `Body` располагает все свои элементы сверху вниз в столбик. Здесь также стоит отметить, что при ширине от 600px и выше для заполнения всего пространства браузера у `body` устанавливается стиль `height: 100vh;`.

Элементы `header` и `footer` аналогичны. Их свойство `flex: 0 0 5em;` указывают, что при любом изменении контейнера эти элементы будут иметь размер в 5em. То есть они имеют статический размер.

Более сложным является элемент `main`, который определяет основное содержимое. При этом будучи flex-элементом, он также является flex-контейнером для вложенных элементов и управляет их позиционированием. При ширине браузера до 600px он располагает элементы в столбик, что очень удобно на мобильных устройствах.

При ширине от 600px вложенные элементы `nav`, `article` и `aside` располагаются в виде строки. И поскольку при такой ширине браузера родительский элемент `body` заполняет по высоте все пространство браузера, то для заполнения всей высоты контейнера `body` при его изменении у элемента main устанавливается свойство `flex: 1 1 auto;`.

У вложенных в `main` flex-элементов стоит отметить, что элемент навигации `nav` и элемент сайдбара `aside` будут иметь одинаковые размеры при масштабировании контейнера. А элемент `article`, содержащий основное содержимое, будет соответственно больше. При этом хотя `nav` определен после элемента `article`, но благодаря установке свойства `order: -1` блок навигации будет стоять до блока `article`.