# Браузерные события и их обработка

Событие – это сигнал от браузера о том, что что-то произошло. Все DOM-узлы подают такие сигналы (хотя события бывают и не только в DOM).

## Список часто используемых DOM-событий

События мыши:

- `click` – происходит, когда кликнули на элемент левой кнопкой мыши (на устройствах с сенсорными экранами оно происходит при касании).

- `contextmenu` – происходит, когда кликнули на элемент правой кнопкой мыши.

- `mouseover / mouseout` – когда мышь наводится на / покидает элемент.

- `mousedown / mouseup` – когда нажали / отжали кнопку мыши на элементе.

- `mousemove` – при движении мыши.

События на элементах управления:

- `submit` – пользователь отправил форму <form>.

- `focus` – пользователь фокусируется на элементе, например нажимает на `<input>`.

Клавиатурные события:

- `keydown` и `keyup` – когда пользователь нажимает / отпускает клавишу.

События документа:

- `DOMContentLoaded` – когда HTML загружен и обработан, DOM документа полностью построен и доступен.

CSS events:

- `transitionend` – когда CSS-анимация завершена.

## Обработчики событий

Событию можно назначить обработчик, то есть функцию, которая сработает, как только событие произошло.

Обработчик может быть назначен прямо в разметке, в атрибуте, который называется `on<событие>`.

```html
<input value="Нажми меня" onclick="alert('Клик!')" type="button">
```

Атрибут HTML-тега – не самое удобное место для написания большого количества кода, поэтому лучше создать отдельную JavaScript-функцию и вызвать её там.

```html
<script>
  function countRabbits() {
    for(let i=1; i<=3; i++) {
      alert("Кролик номер " + i);
    }
  }
</script>

<input type="button" onclick="countRabbits()" value="Считать кроликов!">
```

Можно назначать обработчик, используя свойство DOM-элемента `on<событие>`.

```html
<input id="elem" type="button" value="Нажми меня!">
<script>
  elem.onclick = function() {
    alert('Спасибо');
  };
</script>
```

Обработчиком можно назначить и уже существующую функцию:

```js
function sayThanks() {
  alert('Спасибо!');
}

elem.onclick = sayThanks;
```

> Обработчик всегда хранится в свойстве DOM-объекта, а атрибут – лишь один из способов его инициализации.

Внутри обработчика события `this` ссылается на текущий элемент, то есть на тот, на котором, как говорят, «висит» (т.е. назначен) обработчик.

```html
<input type="button" id="button" onclick="sayThanks()">
```

> Функция должна быть присвоена как sayThanks, а не sayThanks().

```js
// правильно
button.onclick = sayThanks;

// неправильно
button.onclick = sayThanks();
```

…А вот в разметке, в отличие от свойства, скобки нужны:

```html
<input type="button" id="button" onclick="sayThanks()">
```

### addEventListener

При помощи специальных методов `addEventListener` и `removeEventListener` можно добавить несколько обработчиков для одного события.

```js
lement.addEventListener(event, handler, [options]);
```

`event`
Имя события, например "click".

`handler`
Ссылка на функцию-обработчик.

`options`
Дополнительный объект со свойствами:
 - once`: если true, тогда обработчик будет автоматически удалён после выполнения.

 - capture: фаза, на которой должен сработать обработчик, подробнее об этом будет рассказано в главе Всплытие и погружение. Так исторически сложилось, что options может быть false/true, это то же самое, что {capture: false/true}.

 - passive: если true, то указывает, что обработчик никогда не вызовет preventDefault(), подробнее об этом будет рассказано в главе Действия браузера по умолчанию.

Для удаления обработчика следует использовать `removeEventListener`:

```js
element.removeEventListener(event, handler, [options]);
```

> Обработчики некоторых событий можно назначать только через addEventListener

Например, таково событие DOMContentLoaded, которое срабатывает, когда завершена загрузка и построение DOM документа.

```js
document.onDOMContentLoaded = function() {
  alert("DOM построен"); // не будет работать
};

document.addEventListener("DOMContentLoaded", function() {
  alert("DOM построен"); // а вот так сработает
});
```

### Объект события

Чтобы хорошо обработать событие, могут понадобиться детали того, что произошло. Не просто «клик» или «нажатие клавиши», а также – какие координаты указателя мыши, какая клавиша нажата и так далее.

```js
<input type="button" value="Нажми меня" id="elem">

<script>
  elem.onclick = function(event) {
    // вывести тип события, элемент и координаты клика
    alert(event.type + " на " + event.currentTarget);
    alert("Координаты: " + event.clientX + ":" + event.clientY);
  };
</script>
```

### Всплытие

Принцип всплытия очень простой.

> Когда на элементе происходит событие, обработчики сначала срабатывают на нём, потом на его родителе, затем выше и так далее, вверх по цепочке предков.

Например, есть 3 вложенных элемента FORM > DIV > P с обработчиком на каждом:

```html
<style>
  body * {
    margin: 10px;
    border: 1px solid blue;
  }
</style>

<form onclick="alert('form')">FORM
  <div onclick="alert('div')">DIV
    <p onclick="alert('p')">P</p>
  </div>
</form>
```

> Не все события всплывают. Например, событие focus не всплывает. 

Всегда можно узнать, на каком конкретно элементе произошло событие.

Самый глубокий элемент, который вызывает событие, называется _**целевым**_ элементом, и он доступен через `event.target`.

Отличия от `this (=event.currentTarget)`:

`event.target` – это «целевой» элемент, на котором произошло событие, в процессе всплытия он неизменен.

`this` – это «текущий» элемент, до которого дошло всплытие, на нём сейчас выполняется обработчик.

Всплытие идёт с «целевого» элемента прямо наверх. По умолчанию событие будет всплывать до элемента `<html>`, а затем до объекта `document`, а иногда даже до `window`, вызывая все обработчики на своём пути.

Но любой промежуточный обработчик может решить, что событие полностью обработано, и остановить всплытие.

Для этого нужно вызвать метод `event.stopPropagation()`, который  препятствует продвижению события дальше, но на текущем элементе все обработчики будут вызваны.

Если у элемента есть несколько обработчиков на одно событие, то даже при прекращении всплытия все они будут выполнены.

Для того, чтобы полностью остановить обработку, существует метод `event.stopImmediatePropagation()`. Он не только предотвращает всплытие, но и останавливает обработку событий на текущем элементе.

Зачастую нет никакой необходимости прекращать всплытие. Задача, которая, казалось бы, требует этого, может быть решена иначе. Например, с помощью создания своего уникального события, о том, как это делать, мы поговорим позже. Также мы можем записывать какую-то служебную информацию в объект event в одном обработчике, а читать в другом, таким образом мы можем сообщить обработчикам на родительских элементах информацию о том, что событие уже было как-то обработано.

### Погружение

Существует ещё одна фаза из жизненного цикла события – «погружение» (иногда её называют «перехват»). Она очень редко используется в реальном коде, однако тоже может быть полезной.

Стандарт DOM Events описывает 3 фазы прохода события:

1. Фаза погружения (capturing phase) – событие сначала идёт сверху вниз.

2. Фаза цели (target phase) – событие достигло целевого(исходного) элемента.

3. Фаза всплытия (bubbling stage) – событие начинает всплывать.

Чтобы поймать событие на стадии погружения, нужно использовать третий аргумент capture вот так:

```js
elem.addEventListener(..., {capture: true})
// или просто "true", как сокращение для {capture: true}
elem.addEventListener(..., true)
```

Существуют два варианта значений опции capture:

- Если аргумент `false` (по умолчанию), то событие будет поймано при всплытии.

- Если аргумент `true`, то событие будет перехвачено при погружении.

```html
<style>
  body * {
    margin: 10px;
    border: 1px solid blue;
  }
</style>

<form>FORM
  <div>DIV
    <p>P</p>
  </div>
</form>

<script>
  for(let elem of document.querySelectorAll('*')) {
    elem.addEventListener("click", e => alert(`Погружение: ${elem.tagName}`), true);
    elem.addEventListener("click", e => alert(`Всплытие: ${elem.tagName}`));
  }
</script>
```

Если вы кликните по `<p>`, то последовательность следующая:

1. `HTML → BODY → FORM → DIV` (фаза погружения, первый обработчик)

2. `P` (фаза цели, срабатывают обработчики, установленные и на погружение и на всплытие, так что выведется два раза)

3. `DIV → FORM → BODY → HTML` (фаза всплытия, второй обработчик)

**Итого**

При наступлении события – самый глубоко вложенный элемент, на котором оно произошло, помечается как «целевой» (`event.target`).

Затем событие сначала двигается вниз от корня документа к event.target, по пути вызывая обработчики, поставленные через `addEventListener(...., true)`, где `true` – это сокращение для `{capture: true}`.

Далее обработчики вызываются на целевом элементе.

Далее событие двигается от event.target вверх к корню документа, по пути вызывая обработчики, поставленные через `on<event>` и `addEventListener` без третьего аргумента или с третьим аргументом равным `false`.

Каждый обработчик имеет доступ к свойствам события `event`:

- `event.target` – самый глубокий элемент, на котором произошло событие.

- `event.currentTarget` (=this) – элемент, на котором в данный момент сработал обработчик (тот, на котором «висит» конкретный обработчик)

- `event.eventPhase` – на какой фазе он сработал (погружение=1, фаза цели=2, всплытие=3).

Любой обработчик может остановить событие вызовом `event.stopPropagation()`, но делать это не рекомендуется, так как в дальнейшем это событие может понадобиться, иногда для самых неожиданных вещей.

В современной разработке стадия погружения используется очень редко, обычно события обрабатываются во время всплытия. И в этом есть логика.