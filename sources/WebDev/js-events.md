# Браузерные события и их обработка

Событие – это сигнал от браузера о том, что что-то произошло. Все DOM-узлы подают такие сигналы (хотя события бывают и не только в DOM).

## Список часто используемых DOM-событий

События мыши:

- `click` – происходит, когда кликнули на элемент левой кнопкой мыши (на устройствах с сенсорными экранами оно происходит при касании).

- `contextmenu` – происходит, когда кликнули на элемент правой кнопкой мыши.

- `mouseover / mouseout` – когда мышь наводится на / покидает элемент.

- `mousedown / mouseup` – когда нажали / отжали кнопку мыши на элементе.

- `mousemove` – при движении мыши.

События на элементах управления:

- `submit` – пользователь отправил форму <form>.

- `focus` – пользователь фокусируется на элементе, например нажимает на `<input>`.

Клавиатурные события:

- `keydown` и `keyup` – когда пользователь нажимает / отпускает клавишу.

События документа:

- `DOMContentLoaded` – когда HTML загружен и обработан, DOM документа полностью построен и доступен.

CSS events:

- `transitionend` – когда CSS-анимация завершена.

## Обработчики событий

Событию можно назначить обработчик, то есть функцию, которая сработает, как только событие произошло.

Обработчик может быть назначен прямо в разметке, в атрибуте, который называется `on<событие>`.

```html
<input value="Нажми меня" onclick="alert('Клик!')" type="button">
```

Атрибут HTML-тега – не самое удобное место для написания большого количества кода, поэтому лучше создать отдельную JavaScript-функцию и вызвать её там.

```html
<script>
  function countRabbits() {
    for(let i=1; i<=3; i++) {
      alert("Кролик номер " + i);
    }
  }
</script>

<input type="button" onclick="countRabbits()" value="Считать кроликов!">
```

Можно назначать обработчик, используя свойство DOM-элемента `on<событие>`.

```html
<input id="elem" type="button" value="Нажми меня!">
<script>
  elem.onclick = function() {
    alert('Спасибо');
  };
</script>
```

Обработчиком можно назначить и уже существующую функцию:

```js
function sayThanks() {
  alert('Спасибо!');
}

elem.onclick = sayThanks;
```

> Обработчик всегда хранится в свойстве DOM-объекта, а атрибут – лишь один из способов его инициализации.

Внутри обработчика события `this` ссылается на текущий элемент, то есть на тот, на котором, как говорят, «висит» (т.е. назначен) обработчик.

```html
<input type="button" id="button" onclick="sayThanks()">
```

> Функция должна быть присвоена как sayThanks, а не sayThanks().

```js
// правильно
button.onclick = sayThanks;

// неправильно
button.onclick = sayThanks();
```

…А вот в разметке, в отличие от свойства, скобки нужны:

```html
<input type="button" id="button" onclick="sayThanks()">
```

### addEventListener

При помощи специальных методов `addEventListener` и `removeEventListener` можно добавить несколько обработчиков для одного события.

```js
lement.addEventListener(event, handler, [options]);
```

`event`
Имя события, например "click".

`handler`
Ссылка на функцию-обработчик.

`options`
Дополнительный объект со свойствами:
 - once`: если true, тогда обработчик будет автоматически удалён после выполнения.

 - capture: фаза, на которой должен сработать обработчик, подробнее об этом будет рассказано в главе Всплытие и погружение. Так исторически сложилось, что options может быть false/true, это то же самое, что {capture: false/true}.

 - passive: если true, то указывает, что обработчик никогда не вызовет preventDefault(), подробнее об этом будет рассказано в главе Действия браузера по умолчанию.

Для удаления обработчика следует использовать `removeEventListener`:

```js
element.removeEventListener(event, handler, [options]);
```

> Обработчики некоторых событий можно назначать только через addEventListener

Например, таково событие DOMContentLoaded, которое срабатывает, когда завершена загрузка и построение DOM документа.

```js
document.onDOMContentLoaded = function() {
  alert("DOM построен"); // не будет работать
};

document.addEventListener("DOMContentLoaded", function() {
  alert("DOM построен"); // а вот так сработает
});
```

### Объект события

Чтобы хорошо обработать событие, могут понадобиться детали того, что произошло. Не просто «клик» или «нажатие клавиши», а также – какие координаты указателя мыши, какая клавиша нажата и так далее.

```js
<input type="button" value="Нажми меня" id="elem">

<script>
  elem.onclick = function(event) {
    // вывести тип события, элемент и координаты клика
    alert(event.type + " на " + event.currentTarget);
    alert("Координаты: " + event.clientX + ":" + event.clientY);
  };
</script>
```

### Всплытие

Принцип всплытия очень простой.

> Когда на элементе происходит событие, обработчики сначала срабатывают на нём, потом на его родителе, затем выше и так далее, вверх по цепочке предков.

Например, есть 3 вложенных элемента FORM > DIV > P с обработчиком на каждом:

```html
<style>
  body * {
    margin: 10px;
    border: 1px solid blue;
  }
</style>

<form onclick="alert('form')">FORM
  <div onclick="alert('div')">DIV
    <p onclick="alert('p')">P</p>
  </div>
</form>
```

> Не все события всплывают. Например, событие focus не всплывает. 

Всегда можно узнать, на каком конкретно элементе произошло событие.

Самый глубокий элемент, который вызывает событие, называется _**целевым**_ элементом, и он доступен через `event.target`.

Отличия от `this (=event.currentTarget)`:

`event.target` – это «целевой» элемент, на котором произошло событие, в процессе всплытия он неизменен.

`this` – это «текущий» элемент, до которого дошло всплытие, на нём сейчас выполняется обработчик.

Всплытие идёт с «целевого» элемента прямо наверх. По умолчанию событие будет всплывать до элемента `<html>`, а затем до объекта `document`, а иногда даже до `window`, вызывая все обработчики на своём пути.

Но любой промежуточный обработчик может решить, что событие полностью обработано, и остановить всплытие.

Для этого нужно вызвать метод `event.stopPropagation()`, который  препятствует продвижению события дальше, но на текущем элементе все обработчики будут вызваны.

Если у элемента есть несколько обработчиков на одно событие, то даже при прекращении всплытия все они будут выполнены.

Для того, чтобы полностью остановить обработку, существует метод `event.stopImmediatePropagation()`. Он не только предотвращает всплытие, но и останавливает обработку событий на текущем элементе.

Зачастую нет никакой необходимости прекращать всплытие. Задача, которая, казалось бы, требует этого, может быть решена иначе. Например, с помощью создания своего уникального события, о том, как это делать, мы поговорим позже. Также мы можем записывать какую-то служебную информацию в объект event в одном обработчике, а читать в другом, таким образом мы можем сообщить обработчикам на родительских элементах информацию о том, что событие уже было как-то обработано.

### Погружение

Существует ещё одна фаза из жизненного цикла события – «погружение» (иногда её называют «перехват»). Она очень редко используется в реальном коде, однако тоже может быть полезной.

Стандарт DOM Events описывает 3 фазы прохода события:

1. Фаза погружения (capturing phase) – событие сначала идёт сверху вниз.

2. Фаза цели (target phase) – событие достигло целевого(исходного) элемента.

3. Фаза всплытия (bubbling stage) – событие начинает всплывать.

Чтобы поймать событие на стадии погружения, нужно использовать третий аргумент capture вот так:

```js
elem.addEventListener(..., {capture: true})
// или просто "true", как сокращение для {capture: true}
elem.addEventListener(..., true)
```

Существуют два варианта значений опции capture:

- Если аргумент `false` (по умолчанию), то событие будет поймано при всплытии.

- Если аргумент `true`, то событие будет перехвачено при погружении.

```html
<style>
  body * {
    margin: 10px;
    border: 1px solid blue;
  }
</style>

<form>FORM
  <div>DIV
    <p>P</p>
  </div>
</form>

<script>
  for(let elem of document.querySelectorAll('*')) {
    elem.addEventListener("click", e => alert(`Погружение: ${elem.tagName}`), true);
    elem.addEventListener("click", e => alert(`Всплытие: ${elem.tagName}`));
  }
</script>
```

Если вы кликните по `<p>`, то последовательность следующая:

1. `HTML → BODY → FORM → DIV` (фаза погружения, первый обработчик)

2. `P` (фаза цели, срабатывают обработчики, установленные и на погружение и на всплытие, так что выведется два раза)

3. `DIV → FORM → BODY → HTML` (фаза всплытия, второй обработчик)

**Итого**

При наступлении события – самый глубоко вложенный элемент, на котором оно произошло, помечается как «целевой» (`event.target`).

Затем событие сначала двигается вниз от корня документа к event.target, по пути вызывая обработчики, поставленные через `addEventListener(...., true)`, где `true` – это сокращение для `{capture: true}`.

Далее обработчики вызываются на целевом элементе.

Далее событие двигается от event.target вверх к корню документа, по пути вызывая обработчики, поставленные через `on<event>` и `addEventListener` без третьего аргумента или с третьим аргументом равным `false`.

Каждый обработчик имеет доступ к свойствам события `event`:

- `event.target` – самый глубокий элемент, на котором произошло событие.

- `event.currentTarget` (=this) – элемент, на котором в данный момент сработал обработчик (тот, на котором «висит» конкретный обработчик)

- `event.eventPhase` – на какой фазе он сработал (погружение=1, фаза цели=2, всплытие=3).

Любой обработчик может остановить событие вызовом `event.stopPropagation()`, но делать это не рекомендуется, так как в дальнейшем это событие может понадобиться, иногда для самых неожиданных вещей.

В современной разработке стадия погружения используется очень редко, обычно события обрабатываются во время всплытия. И в этом есть логика.

### Делегирование событий

Всплытие и перехват событий позволяет реализовать один из самых важных приёмов разработки – делегирование.

Идея в том, что если у нас есть много элементов, события на которых нужно обрабатывать похожим образом, то вместо того, чтобы назначать обработчик каждому, мы ставим один обработчик на их общего предка.

Из него можно получить целевой элемент `event.target`, понять на каком именно потомке произошло событие и обработать его.

### Пример. Меню с кнопками:

```html

<div id="menu">
  <button data-action="save">Сохранить</button>
  <button data-action="load">Загрузить</button>
  <button data-action="search">Поиск</button>
</div>

<script>
  class Menu {
    constructor(elem) {
      elem.onclick = this.onClick.bind(this); // (*)
    }

    save() {
      alert('сохраняю');
    }

    load() {
      alert('загружаю');
    }

    search() {
      alert('ищу');
    }

    onClick(event) {
      let action = event.target.dataset.action;
      if (action) {
        this[action]();
      }
    }
  }

  new Menu(menu);
</script>
```

> Метод `this.onClick` в строке, отмеченной звёздочкой (*), привязывается к контексту текущего объекта `this`. Это важно, т.к. иначе `this` внутри него будет ссылаться на DOM-элемент (elem), а не на объект Menu, и `this[action]` будет не тем, что нам нужно.

### Пример. Переключатель.

Ещё один пример поведения. Сделаем так, что при клике на элемент с атрибутом data-toggle-id будет скрываться/показываться элемент с заданным id:

```html
<button data-toggle-id="subscribe-mail">
  Показать форму подписки
</button>

<form id="subscribe-mail" hidden>
  Ваша почта: <input type="email">
</form>

<script>
  document.addEventListener('click', function(event) {
    let id = event.target.dataset.toggleId;
    if (!id) return;

    let elem = document.getElementById(id);

    elem.hidden = !elem.hidden;
  });
</script>
```

> Теперь для того, чтобы добавить скрытие-раскрытие любому элементу, можно просто написать атрибут `data-toggle-id`.

### [Действия браузера по умолчанию](https://learn.javascript.ru/default-browser-action)

Действий браузера по умолчанию достаточно много:

- `mousedown` – начинает выделять текст (если двигать мышкой).

- `click` на `<input type="checkbox">` – ставит или убирает галочку в input.

- `submit` – при нажатии на `<input type="submit">` или при нажатии клавиши Enter в форме данные отправляются на сервер.

- `keydown` – при нажатии клавиши в поле ввода появляется символ.

- `contextmenu` – при правом клике показывается контекстное меню браузера.

- …и многие другие…

Все эти действия можно отменить, если мы хотим обработать событие исключительно при помощи JavaScript.

Чтобы отменить действие браузера по умолчанию, используйте `event.preventDefault()` или `return false`. Второй метод работает, только если обработчик назначен через `on<событие>`.

Опция `passive: true` для `addEventListener` сообщает браузеру, что действие по умолчанию не будет отменено. Это очень полезно для некоторых событий на мобильных устройствах, таких как touchstart и touchmove, чтобы сообщить браузеру, что он не должен ожидать выполнения всех обработчиков, а ему следует сразу приступать к выполнению действия по умолчанию, например, к прокрутке.

Если событие по умолчанию отменено, то значение `event.defaultPrevented` становится `true`, иначе `false`.

## [Генерация событий](https://learn.javascript.ru/dispatch-events)

Можно генерировать не только совершенно новые, придуманные нами события, но и встроенные, такие как click, mousedown и другие. Это бывает полезно для автоматического тестирования.

### Конструктор Events

Встроенные классы для событий формируют иерархию аналогично классам для DOM-элементов. Её корнем является встроенный класс Event.

Событие встроенного класса Event можно создать так:

```js
let event = new Event(type[, options]);
```

Где:

- type – тип события, строка, например "click" или же любой придуманный нами – "my-event".

- options – объект с тремя необязательными свойствами:

  - bubbles: true/false – если true, тогда событие всплывает.

  - cancelable: true/false – если true, тогда можно отменить действие по умолчанию. 

  - composed: true/false – если true, тогда событие будет всплывать наружу за пределы Shadow DOM. 

По умолчанию все три свойства установлены в false: {bubbles: false, cancelable: false, composed: false}.

### Метод `dispatchEvent`

После того, как объект события создан, мы должны запустить его на элементе, вызвав метод `elem.dispatchEvent(event)`.

Затем обработчики отреагируют на него, как будто это обычное браузерное событие. Если при создании указан флаг `bubbles`, то оно будет всплывать.

В примере ниже событие `click` инициируется JavaScript-кодом так, как будто кликнули по кнопке:

```html
<button id="elem" onclick="alert('Клик!');">Автоклик</button>

<script>
  let event = new Event("click");
  elem.dispatchEvent(event);
</script>
```
> Можно легко отличить «настоящее» событие от сгенерированного кодом.Свойство `event.isTrusted` принимает значение `true` для событий, порождаемых реальными действиями пользователя, и `false` для генерируемых кодом.

### Пользовательские события

Для генерации событий совершенно новых типов, таких как "hello", следует использовать конструктор `new CustomEvent`. Технически `CustomEvent` абсолютно идентичен `Event` за исключением одной небольшой детали.

У второго аргумента-объекта есть дополнительное свойство `detail`, в котором можно указывать информацию для передачи в событие.

```html
<h1 id="elem">Привет для Васи!</h1>

<script>
  // дополнительная информация приходит в обработчик вместе с событием
  elem.addEventListener("hello", function(event) {
    alert(event.detail.name);
  });

  elem.dispatchEvent(new CustomEvent("hello", {
    detail: { name: "Вася" }
  }));
</script>
```

## [Selection и Range]

[Ссылка на статью](https://learn.javascript.ru/selection-range)
