# JavaScript

[DOM](js-dom.md)

[Работа со стилями и классами CSS](./js-css.md)

[Браузерные события и их обработка](./js-events.md)

[Работа с формами](js-forms.md)

[Вызов REST API из JavaScript](https://sky.pro/media/vyzov-rest-api-iz-javascript/)

### Типы данных

В JavaScript есть 8 основных типов данных.

Семь из них называют «примитивными» типами данных:

- `number` для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном ±(2<sup>53</sup>).

- `bigint` для целых чисел произвольной длины.

- `string` для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.

- `boolean` для true/false.

- `null` для неизвестных значений – отдельный тип, имеющий одно значение null.

- `undefined` для неприсвоенных значений – отдельный тип, имеющий одно значение undefined.

- `symbol` для уникальных идентификаторов.

И один не является «примитивным» и стоит особняком:

- `object` для более сложных структур данных.

Оператор `typeof` позволяет нам увидеть, какой тип данных сохранён в переменной.

Имеет две формы: `typeof x`или `typeof(x)`.
Возвращает строку с именем типа. Например, "string".
Для `null` возвращается "object" – это ошибка в языке, на самом деле это не объект.

### Переменные 

Объявление переменных:

```js
let str = "stroka";

var str = 'stroka'; // Устаревшее
```

Использование ключевого слова `var` нежелательно. Переменная, объявленная таким образом видима вне блока {}. Кроме того, существует эффект "всплытия", когда объявление `var = ...` переменной фактически происходит в начале функции, вне зависимости от действительного её расположения в коде, а присвоение значения в момент обращения к ней.

### Работа с примитивами

В JS можно обращаться к методам примитивов:

```js
alert((123.36).toFixed(1));
// метод toFixed округляет и возвращает строку

alert("12sdf4".length)
// length - не метод, а свойство, поэтому без()!

alert("12sdf4".[2])
alert("12sdf4".at(-2))
// получение символа из строки. В случае с 'at' возможна относительная адресация

alert( 'Interface'.toUpperCase() ); // INTERFACE

alert( 'Interface'.toLowerCase() ); // interface
```

Для округления чисел можно воспользоваться статическими методами класса `Math`:

```js
Math.flor();
// Округление в меньшую сторону 3.1->3 -1.1->-2

Math.ceil();
// Округление в большую сторону 3.1->4 -1.1->-1

Math.round();
// Округление до ближайшего целого 3.6->4 -1.1->-1

Math.trunc();
// Удаление дробной части 3.1->3 -1.1->-1
```

### Проверка: isFinite и isNaN

`Infinity` (и `-Infinity`) — особенное численное значение, которое ведёт себя в точности как математическая бесконечность ∞.

`NaN` представляет ошибку.


- `isNaN(value)` преобразует значение в число и проверяет является ли оно NaN:

```js
alert( isNaN(NaN) ); // true
alert( isNaN("str") ); // true
```

- `isFinite(value)` преобразует аргумент в число и возвращает true, если оно является обычным числом, т.е. не NaN/Infinity/-Infinity:

```js

isFinite("15"); // true
alert( isFinite("str") ); // false, потому что специальное значение: NaN

alert( isFinite(Infinity) ); // false, потому что специальное значение: Infinity
```

### parseInt и parseFloat

Они «читают» число из строки. Если в процессе чтения возникает ошибка, они возвращают полученное до ошибки число. Функция parseInt возвращает целое число, а parseFloat возвращает число с плавающей точкой:

```js
alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5

alert( parseInt('12.3') ); // 12, вернётся только целая часть
alert( parseFloat('12.3.4') ); // 12.3, произойдёт остановка чтения на второй точке
```

Функции parseInt/parseFloat вернут NaN, если не смогли прочитать ни одну цифру:

```js
alert( parseInt('a123') ); // NaN, на первом символе происходит остановка чтения
```

Функция parseInt() имеет необязательный второй параметр. Он определяет систему счисления, таким образом parseInt может также читать строки с шестнадцатеричными числами, двоичными числами и т.д.:

```js
alert( parseInt('0xff', 16) ); // 255
alert( parseInt('ff', 16) ); // 255, без 0x тоже работает

alert( parseInt('2n9c', 36) ); // 123456
```

### Массивы


Два варианта создания массива:

```js
let arr = new Array();
let arr = [];
```

В JS массивы могут содержать элементы различных типов (не рекомендуется, вследствие падения эффективности);

```js
let arr = [ 'Яблоко', { name: 'Джон' }, true, function() { alert('привет'); } ];
```

Некоторые методы:

```js
array.at(-1); // предпоследний элемент

array.push(элемент); //добавляет элемент в конец массива

array.pop(); // удаляет (и возвращает) последний элемент

array.shift(); // удаляет (и возвращает) первый элемент

array.unshift(элемент); // добавляет элемент в начало массива

// Методы push/pop выполняются быстро, а методы shift/unshift – медленно.

arr.splice(start[, deleteCount, elem1, ..., elemN]);
//  изменяет arr начиная с индекса start: удаляет deleteCount элементов и затем вставляет elem1, ..., elemN на их место. Возвращает массив из удалённых элементов. start: можно отрицательный
// Пример:
let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];
let removed = arr.splice(0, 2);
alert( removed ); // "Я", "изучаю" <-- массив из удалённых элементов

arr.concat(arg1, arg2...)
// принимает любое количество аргументов, которые могут быть как массивами, так и простыми значениями.В результате – новый массив, включающий в себя элементы из arr, затем arg1, arg2 и так далее.

arr.forEach(function(item, index, array) {
  // ... делать что-то с item
});
// Пример:
["Бильбо", "Гэндальф", "Назгул"].forEach((item, index, array) => {
  alert(`У ${item} индекс ${index} в ${array}`);
});
// Пример:
["Бильбо", "Гэндальф", "Назгул"].forEach(alert);
// Результат функции (если она что-то возвращает) отбрасывается и игнорируется.

arr.indexOf(item, from); 
// ищет item начиная с индекса from и возвращает номер индекса, на котором был найден искомый элемент, в противном случае -1.

arr.includes(item, from);
// ищет item начиная с индекса from и возвращает true, если поиск успешен.

arr.find(function(item, index, array) {
 // если true - возвращается текущий элемент и перебор прерывается
 // если все итерации оказались ложными, возвращается undefined
 //Если функция возвращает true, поиск прерывается и возвращается item. Если ничего не найдено, возвращается undefined.
 // Пример:
let users = [
  {id: 1, name: "Вася"},
  {id: 2, name: "Петя"},
  {id: 3, name: "Маша"}
];
let user = users.find(item => item.id == 1);
});

arr.filter(function(item, index, array) {
  // если `true` -- элемент добавляется к results и перебор продолжается
  // возвращается пустой массив в случае, если ничего не найдено
});
// В отличии от find() возвращает массив из всех совпадений.


arr.map(function(item, index, array) {
  // возвращается новое значение вместо элемента
});
// вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции.

arr.sort();
// сортирует массив на месте, меняя в нём порядок элементов.
// По умолчанию элементы сортируются как строки!!!
// Чтобы использовать наш собственный порядок сортировки, нам нужно предоставить функцию в качестве аргумента arr.sort().
// Функция должна для пары значений возвращать, например:
function compare(a, b) {
  if (a > b) return 1; // если первое значение больше второго
  if (a == b) return 0; // если равны
  if (a < b) return -1; // если первое значение меньше второго
}
// Пример:
[1, -2, 15, 2, 0, 8].sort(function(a, b) {
  return a - b;
});
// На самом деле от функции сравнения требуется любое положительное число, чтобы сказать «больше», и отрицательное число, чтобы сказать «меньше».
arr.sort( (a, b) => a - b );
// Используйте localeCompare для строк
let countries = ['Österreich', 'Andorra', 'Vietnam'];
alert( countries.sort( (a, b) => a > b ? 1 : -1) ); // Andorra, Vietnam, Österreich (неправильно)
alert( countries.sort( (a, b) => a.localeCompare(b) ) ); // Andorra,Österreich,Vietnam (правильно!)

arr.reduce(function(accumulator, item, index, array) {
  // ...
}, [initial]);
// используются для вычисления единого значения на основе всего массива.
// accumulator – результат предыдущего вызова этой функции, равен initial при первом вызове (если передан initial),
// item – очередной элемент массива,
// index – его позиция,
// array – сам массив.
let arr = [1, 2, 3, 4, 5];
let result = arr.reduce((sum, current) => sum + current, 0);

// .......
```

Перебор массива:

```js
et arr = ["Яблоко", "Апельсин", "Груша"];

for (let i = 0; i < arr.length; i++) {
  alert( arr[i] );
}

for (let fruit of fruits) {
  alert( fruit );
}


for (let key in arr) {
  alert( arr[key] ); // Яблоко, Апельсин, Груша
}
// не лучший вариант, потому что перебирает все свойства объекта

// Пример с перебором свойств объекта:

let user = {
  name: "John",
  age: 30,
  isAdmin: true
};

for (let key in user) {
  // ключи
  alert( key );  // name, age, isAdmin
  // значения ключей
  alert( user[key] ); // John, 30, true
}
```

### Map

Методы и свойства:

```js
new Map() // создаёт коллекцию.

map.set(key, value) // записывает по ключу key значение value.

map.get(key) // возвращает значение по ключу или undefined, если ключ key отсутствует.

map.has(key) // возвращает true, если ключ key присутствует в коллекции, иначе false.

map.delete(key) // удаляет элемент (пару «ключ/значение») по ключу key.

map.clear() // очищает коллекцию от всех элементов.

map.size // возвращает текущее количество элементов.

map.keys() // возвращает итерируемый объект по ключам,

map.values() // возвращает итерируемый объект по значениям,

map.entries() // возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в for..of.

// выполняем функцию для каждой пары (ключ, значение)
recipeMap.forEach((value, key, map) => {
  alert(`${key}: ${value}`); // огурец: 500 и так далее
});
```

### Set

```js
let set = new Set()

new Set(iterable) // создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый Set.

set.add(value) // добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.

set.delete(value) // удаляет значение, возвращает true, если value было в множестве на момент вызова, иначе false.

set.has(value) // возвращает true, если значение присутствует в множестве, иначе false.

set.clear() // удаляет все имеющиеся значения.

set.size // возвращает количество элементов в множестве.

set.values() // возвращает перебираемый объект для значений,

set.keys() // то же самое, что и set.values(), присутствует для обратной совместимости с Map,

set.entries() // возвращает перебираемый объект для пар вида [значение, значение], присутствует для обратной совместимости с Map.
```

Перебор объекта Set:

```js
let set = new Set(["апельсин", "яблоко", "банан"]);

for (let value of set) alert(value);

// то же самое с forEach:
set.forEach((value, valueAgain, set) => {
  alert(value);
});
```

### Деструктурирующее присваивание

_Деструктурирующее присваивание_ – это специальный синтаксис, который позволяет нам «распаковать» массивы или объекты в несколько переменных, так как иногда они более удобны.

Деструктуризация массива:

```js
// у нас есть массив с именем и фамилией
let arr = ["Ilya", "Kantor"];

// деструктурирующее присваивание
// записывает firstName = arr[0]
// и surname = arr[1]
let [firstName, surname] = arr;

alert(firstName); // Ilya
alert(surname);  // Kantor
```

**Работает с любым перебираемым объектом с правой стороны**

### Деструктуризация объекта

```js
let {var1, var2} = {var1:…, var2:…}

// Пример:
let options = {
  title: "Menu",
  width: 100,
  height: 200
};
let {title, width, height} = options;
alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
```

### Дата и время

Встречайте новый встроенный объект: Date. Он содержит дату и время, а также предоставляет методы управления ими.

```js
new Date() // создать объект Date с текущими датой и временем

new Date(milliseconds) // Создать объект Date с временем, равным количеству миллисекунд (тысячная доля секунды), прошедших с 1 января 1970 года UTC+0.

// Целое число, представляющее собой количество миллисекунд, прошедших с начала 1970 года, называется таймстамп (англ. timestamp).

new Date(datestring) // Если аргумент всего один, и это строка, то из неё «прочитывается» дата. Алгоритм разбора – такой же, как в Date.parse, который мы рассмотрим позже.

new Date(year, month, date, hours, minutes, seconds, ms) // Создать объект Date с заданными компонентами в местном часовом поясе. Обязательны только первые два аргумента.

// year должен состоять из четырёх цифр. Для совместимости также принимаются 2 цифры и рассматриваются как 19xx, к примеру, 98 здесь это тоже самое, что и 1998, но настоятельно рекомендуется всегда использовать 4 цифры.

// month начинается с 0 (январь) по 11 (декабрь).

// Параметр date здесь представляет собой день месяца. Если параметр не задан, то принимается значение 1.

// Если параметры hours/minutes/seconds/ms отсутствуют, их значением становится 0.

```

Получение компонентов даты:

```js
getFullYear() //Получить год (4 цифры)

getMonth() // Получить месяц, от 0 до 11.

getDate() // Получить день месяца, от 1 до 31, что несколько противоречит названию метода.

getDay() // Вернуть день недели от 0 (воскресенье) до 6 (суббота). Несмотря на то, что в ряде стран за первый день недели принят понедельник, в JavaScript начало недели приходится на воскресенье.

Date.now() // возвращает текущую метку времени.

```

Установка компонентов даты:

```js
setFullYear(year, [month], [date])

setMonth(month, [date])

setDate(date)

setHours(hour, [min], [sec], [ms])

setMinutes(min, [sec], [ms])

setSeconds(sec, [ms])

setMilliseconds(ms)

setTime(milliseconds) // (устанавливает дату в виде целого количества миллисекунд, прошедших с 01.01.1970 UTC)
```

### Опциональная цепочка

Опциональная цепочка `?`. останавливает вычисление и возвращает `undefined`, 
если значение перед `?`. равно `undefined` или `null`.

Это помогает избегать ошибок при обращении к несуществующему свойоству объекта.

Вот безопасный способ получить доступ к user.address.street, используя ?.:

```js
let user = {}; // пользователь без адреса

alert( user?.address?.street ); // undefined (без ошибки)
```

### Примеси

 _**примесь**_ – это класс, методы которого предназначены для использования в других классах, причём без наследования от примеси.

Простейший способ реализовать примесь в JavaScript – это создать объект с полезными методами, которые затем могут быть легко добавлены в прототип любого класса:

```js
// примесь
let sayHiMixin = {
  sayHi() {
    alert(`Привет, ${this.name}`);
  },
  sayBye() {
    alert(`Пока, ${this.name}`);
  }
};

// использование:
class User {
  constructor(name) {
    this.name = name;
  }
}

// копируем методы
Object.assign(User.prototype, sayHiMixin);

// теперь User может сказать Привет
new User("Вася").sayHi(); // Привет, Вася!

```

### Прототипное наследование

В JavaScript объекты имеют специальное скрытое свойство [[Prototype]] (так оно названо в спецификации), которое либо равно null, либо ссылается на другой объект. Этот объект называется «прототип».

Свойство [[Prototype]] является внутренним и скрытым, но есть много способов задать его.

Одним из них является использование __proto__, например так:


```js
let animal = {
  eats: true
};

let rabbit = {
  jumps: true
};

rabbit.__proto__ = animal; // (*)

// теперь мы можем найти оба свойства в rabbit:
alert( rabbit.eats ); // true (**)
alert( rabbit.jumps ); // true
```

Цепочка прототипов может быть длиннее:

```js
let animal = {
  eats: true,
  walk() {
    alert("Animal walk");
  }
};

let rabbit = {
  jumps: true,
  __proto__: animal
};

let longEar = {
  earLength: 10,
  __proto__: rabbit
};

// walk взят из цепочки прототипов
longEar.walk(); // Animal walk
alert(longEar.jumps); // true (из rabbit)

```

Свойство __proto__ немного устарело, оно существует по историческим причинам. Современный JavaScript предполагает, что мы должны использовать функции Object.getPrototypeOf/Object.setPrototypeOf вместо того, чтобы получать/устанавливать прототип.



### Symbol

Символ (symbol) – примитивный тип данных, использующийся для создания уникальных идентификаторов.

Символы создаются вызовом функции Symbol(), в которую можно передать описание (имя) символа.

Даже если символы имеют одно и то же имя, это – разные символы. Если мы хотим, чтобы одноимённые символы были равны, то следует использовать глобальный реестр: вызов Symbol.for(key) возвращает (или создаёт) глобальный символ с key в качестве имени. Многократные вызовы команды Symbol.for с одним и тем же аргументом возвращают один и тот же символ.

Символы имеют два основных варианта использования:

«Скрытые» свойства объектов.

Если мы хотим добавить свойство в объект, который «принадлежит» другому скрипту или библиотеке, мы можем создать символ и использовать его в качестве ключа. Символьное свойство не появится в for..in, так что оно не будет нечаянно обработано вместе с другими. Также оно не будет модифицировано прямым обращением, так как другой скрипт не знает о нашем символе. Таким образом, свойство будет защищено от случайной перезаписи или использования.

Так что, используя символьные свойства, мы можем спрятать что-то нужное нам, но что другие видеть не должны.

Существует множество системных символов, используемых внутри JavaScript, доступных как Symbol.*. Мы можем использовать их, чтобы изменять встроенное поведение ряда объектов. Например, в дальнейших главах мы будем использовать Symbol.iterator для итераторов, Symbol.toPrimitive для настройки преобразования объектов в примитивы и так далее.

Символы игнорируются циклом for…in

```js
let id = Symbol("id");

alert(id.toString()); // Symbol(id), теперь работает

ert(id.description); // id

// Создадим скрытое свойство

let user = {
  name: "Вася"
};

let id = Symbol("id");

user[id] = 1;

alert( user[id] ); // мы можем получить доступ к данным по ключу-символу


```